"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// platforms/react-router.ts
var react_router_exports = {};
__export(react_router_exports, {
  createWorkflow: () => createWorkflow,
  serve: () => serve,
  serveMany: () => serveMany
});
module.exports = __toCommonJS(react_router_exports);

// src/constants.ts
var WORKFLOW_ID_HEADER = "Upstash-Workflow-RunId";
var WORKFLOW_INIT_HEADER = "Upstash-Workflow-Init";
var WORKFLOW_URL_HEADER = "Upstash-Workflow-Url";
var WORKFLOW_CREATED_AT_HEADER = "Upstash-Workflow-CreatedAt";
var WORKFLOW_FAILURE_HEADER = "Upstash-Workflow-Is-Failure";
var WORKFLOW_FAILURE_CALLBACK_HEADER = "Upstash-Workflow-Failure-Callback";
var WORKFLOW_FEATURE_HEADER = "Upstash-Feature-Set";
var WORKFLOW_INVOKE_COUNT_HEADER = "Upstash-Workflow-Invoke-Count";
var WORKFLOW_LABEL_HEADER = "Upstash-Label";
var WORKFLOW_UNKOWN_SDK_VERSION_HEADER = "Upstash-Workflow-Unknown-Sdk";
var WORKFLOW_UNKOWN_SDK_TRIGGER_HEADER = "upstash-workflow-trigger-by-sdk";
var WORKFLOW_PROTOCOL_VERSION = "1";
var WORKFLOW_PROTOCOL_VERSION_HEADER = "Upstash-Workflow-Sdk-Version";
var DEFAULT_CONTENT_TYPE = "application/json";
var NO_CONCURRENCY = 1;
var DEFAULT_RETRIES = 3;
var VERSION = "v1.0.0";
var SDK_TELEMETRY = `@upstash/workflow@${VERSION}`;
var TELEMETRY_HEADER_SDK = "Upstash-Telemetry-Sdk";
var TELEMETRY_HEADER_FRAMEWORK = "Upstash-Telemetry-Framework";
var TELEMETRY_HEADER_RUNTIME = "Upstash-Telemetry-Runtime";

// src/client/utils.ts
var import_qstash2 = require("@upstash/qstash");

// src/error.ts
var import_qstash = require("@upstash/qstash");
var WorkflowError = class extends import_qstash.QstashError {
  constructor(message) {
    super(message);
    this.name = "WorkflowError";
  }
};
var WorkflowAbort = class extends Error {
  stepName;
  stepInfo;
  /**
   * @param stepName name of the aborting step
   * @param stepInfo step information
   */
  constructor(stepName, stepInfo) {
    super(
      `This is an Upstash Workflow error thrown after a step executes. It is expected to be raised. Make sure that you await for each step. Also, if you are using try/catch blocks, you should not wrap context.run/sleep/sleepUntil/call methods with try/catch. Aborting workflow after executing step '${stepName}'.`
    );
    this.name = "WorkflowAbort";
    this.stepName = stepName;
    this.stepInfo = stepInfo;
  }
};
var WorkflowAuthError = class extends WorkflowAbort {
  /**
   * @param stepName name of the step found during authorization
   */
  constructor(stepName) {
    super(stepName);
    this.name = "WorkflowAuthError";
    this.message = `This is an Upstash Workflow error thrown during authorization check. Found step '${stepName}' during dry-run.`;
  }
};
var WorkflowCancelAbort = class extends WorkflowAbort {
  constructor() {
    super("cancel");
    this.name = "WorkflowCancelAbort";
    this.message = "Workflow has been canceled by user via context.cancel().";
  }
};
var WorkflowNonRetryableError = class extends WorkflowAbort {
  /**
   * @param message error message to be displayed
   */
  constructor(message) {
    super("non-retryable-error");
    this.name = "WorkflowNonRetryableError";
    this.message = message ?? "Workflow failed with non-retryable error.";
  }
};
var WorkflowRetryAfterError = class extends WorkflowAbort {
  retryAfter;
  /**
   * @param message error message to be displayed
   * @param retryAfter time in seconds after which the workflow should be retried
   */
  constructor(message, retryAfter) {
    super("retry-after-error");
    this.name = "WorkflowRetryAfterError";
    this.message = message;
    this.retryAfter = retryAfter;
  }
};
var formatWorkflowError = (error) => {
  return error instanceof Error ? {
    error: error.name,
    message: error.message,
    stack: error.stack
  } : {
    error: "Error",
    message: `An error occured while executing workflow: '${typeof error === "string" ? error : JSON.stringify(error)}'`
  };
};
function getConstructorName(obj) {
  if (obj === null || obj === void 0) {
    return null;
  }
  const ctor = obj.constructor;
  if (!ctor || ctor.name === "Object") {
    return null;
  }
  return ctor.name;
}
function getConstructorNames(obj) {
  const proto = Object.getPrototypeOf(obj);
  const name = getConstructorName(proto);
  if (name === null) {
    return [];
  }
  return [name, ...getConstructorNames(proto)];
}
function isInstanceOf(v, ctor) {
  return getConstructorNames(v).includes(ctor.name);
}

// src/client/utils.ts
var makeNotifyRequest = async (requester, eventId, eventData) => {
  const result = await requester.request({
    path: ["v2", "notify", eventId],
    method: "POST",
    body: typeof eventData === "string" ? eventData : JSON.stringify(eventData)
  });
  return result;
};
var makeCancelRequest = async (requester, workflowRunId) => {
  await requester.request({
    path: ["v2", "workflows", "runs", `${workflowRunId}?cancel=true`],
    method: "DELETE",
    parseResponseAsJson: false
  });
  return true;
};
var getSteps = async (requester, workflowRunId, messageId, dispatchDebug) => {
  try {
    const steps = await requester.request({
      path: ["v2", "workflows", "runs", workflowRunId],
      parseResponseAsJson: true
    });
    if (steps.length === 1) {
      return {
        steps,
        workflowRunEnded: false
      };
    }
    if (!messageId) {
      await dispatchDebug?.("onInfo", {
        info: `Pulled ${steps.length} steps from QStashand returned them without filtering with messageId.`
      });
      return { steps, workflowRunEnded: false };
    } else {
      const index = steps.findIndex((item) => item.messageId === messageId);
      if (index === -1) {
        return { steps: [], workflowRunEnded: false };
      }
      const filteredSteps = steps.slice(0, index + 1);
      await dispatchDebug?.("onInfo", {
        info: `Pulled ${steps.length} steps from QStash and filtered them to ${filteredSteps.length} using messageId.`
      });
      return { steps: filteredSteps, workflowRunEnded: false };
    }
  } catch (error) {
    if (isInstanceOf(error, import_qstash2.QstashError) && error.status === 404) {
      await dispatchDebug?.("onWarning", {
        warning: "Couldn't fetch workflow run steps. This can happen if the workflow run succesfully ends before some callback is executed."
      });
      return { steps: void 0, workflowRunEnded: true };
    } else {
      throw error;
    }
  }
};

// src/context/auto-executor.ts
var import_qstash5 = require("@upstash/qstash");

// src/qstash/headers.ts
var import_qstash4 = require("@upstash/qstash");

// src/utils.ts
var NANOID_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_";
var NANOID_LENGTH = 21;
function getRandomInt() {
  return Math.floor(Math.random() * NANOID_CHARS.length);
}
function nanoid(length = NANOID_LENGTH) {
  return Array.from({ length }).map(() => NANOID_CHARS[getRandomInt()]).join("");
}
function getWorkflowRunId(id) {
  return `wfr_${id ?? nanoid()}`;
}
function decodeBase64(base64) {
  const binString = atob(base64);
  try {
    const intArray = Uint8Array.from(binString, (m) => m.codePointAt(0));
    return new TextDecoder().decode(intArray);
  } catch (error) {
    console.warn(
      `Upstash Qstash: Failed while decoding base64 "${base64}". Decoding with atob and returning it instead. ${error}`
    );
    return binString;
  }
}
function getUserIdFromToken(qstashClient) {
  try {
    const token = qstashClient.token;
    const decodedToken = decodeBase64(token);
    const tokenPayload = JSON.parse(decodedToken);
    const userId = tokenPayload.UserID;
    if (!userId) {
      throw new WorkflowError("QStash token payload does not contain userId");
    }
    return userId;
  } catch (error) {
    throw new WorkflowError(
      `Failed to decode QStash token while running create webhook step: ${error.message}`
    );
  }
}
function getQStashUrl(qstashClient) {
  try {
    const requester = qstashClient.http;
    const baseUrl = requester.baseUrl;
    if (!baseUrl) {
      throw new WorkflowError("QStash client does not have a baseUrl");
    }
    return baseUrl;
  } catch (error) {
    throw new WorkflowError(`Failed to get QStash URL from client: ${error.message}`);
  }
}
function getEventId() {
  return `evt_${nanoid(15)}`;
}
function stringifyBody(body) {
  if (body === void 0) {
    return void 0;
  }
  if (typeof body === "string") {
    return body;
  }
  return JSON.stringify(body);
}

// node_modules/neverthrow/dist/index.es.js
var defaultErrorConfig = {
  withStackTrace: false
};
var createNeverThrowError = (message, result, config = defaultErrorConfig) => {
  const data = result.isOk() ? { type: "Ok", value: result.value } : { type: "Err", value: result.error };
  const maybeStack = config.withStackTrace ? new Error().stack : void 0;
  return {
    data,
    message,
    stack: maybeStack
  };
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
var ResultAsync = class _ResultAsync {
  constructor(res) {
    this._promise = res;
  }
  static fromSafePromise(promise) {
    const newPromise = promise.then((value) => new Ok(value));
    return new _ResultAsync(newPromise);
  }
  static fromPromise(promise, errorFn) {
    const newPromise = promise.then((value) => new Ok(value)).catch((e) => new Err(errorFn(e)));
    return new _ResultAsync(newPromise);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static fromThrowable(fn, errorFn) {
    return (...args) => {
      return new _ResultAsync((() => __awaiter(this, void 0, void 0, function* () {
        try {
          return new Ok(yield fn(...args));
        } catch (error) {
          return new Err(errorFn ? errorFn(error) : error);
        }
      }))());
    };
  }
  static combine(asyncResultList) {
    return combineResultAsyncList(asyncResultList);
  }
  static combineWithAllErrors(asyncResultList) {
    return combineResultAsyncListWithAllErrors(asyncResultList);
  }
  map(f) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      return new Ok(yield f(res.value));
    })));
  }
  andThrough(f) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newRes = yield f(res.value);
      if (newRes.isErr()) {
        return new Err(newRes.error);
      }
      return new Ok(res.value);
    })));
  }
  andTee(f) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      try {
        yield f(res.value);
      } catch (e) {
      }
      return new Ok(res.value);
    })));
  }
  mapErr(f) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isOk()) {
        return new Ok(res.value);
      }
      return new Err(yield f(res.error));
    })));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f) {
    return new _ResultAsync(this._promise.then((res) => {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newValue = f(res.value);
      return newValue instanceof _ResultAsync ? newValue._promise : newValue;
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f) {
    return new _ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return f(res.error);
      }
      return new Ok(res.value);
    })));
  }
  match(ok2, _err) {
    return this._promise.then((res) => res.match(ok2, _err));
  }
  unwrapOr(t) {
    return this._promise.then((res) => res.unwrapOr(t));
  }
  /**
   * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.
   */
  safeUnwrap() {
    return __asyncGenerator(this, arguments, function* safeUnwrap_1() {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));
    });
  }
  // Makes ResultAsync implement PromiseLike<Result>
  then(successCallback, failureCallback) {
    return this._promise.then(successCallback, failureCallback);
  }
};
var errAsync = (err2) => new ResultAsync(Promise.resolve(new Err(err2)));
var fromPromise = ResultAsync.fromPromise;
var fromSafePromise = ResultAsync.fromSafePromise;
var fromAsyncThrowable = ResultAsync.fromThrowable;
var combineResultList = (resultList) => {
  let acc = ok([]);
  for (const result of resultList) {
    if (result.isErr()) {
      acc = err(result.error);
      break;
    } else {
      acc.map((list) => list.push(result.value));
    }
  }
  return acc;
};
var combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);
var combineResultListWithAllErrors = (resultList) => {
  let acc = ok([]);
  for (const result of resultList) {
    if (result.isErr() && acc.isErr()) {
      acc.error.push(result.error);
    } else if (result.isErr() && acc.isOk()) {
      acc = err([result.error]);
    } else if (result.isOk() && acc.isOk()) {
      acc.value.push(result.value);
    }
  }
  return acc;
};
var combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);
var Result;
(function(Result2) {
  function fromThrowable2(fn, errorFn) {
    return (...args) => {
      try {
        const result = fn(...args);
        return ok(result);
      } catch (e) {
        return err(errorFn ? errorFn(e) : e);
      }
    };
  }
  Result2.fromThrowable = fromThrowable2;
  function combine(resultList) {
    return combineResultList(resultList);
  }
  Result2.combine = combine;
  function combineWithAllErrors(resultList) {
    return combineResultListWithAllErrors(resultList);
  }
  Result2.combineWithAllErrors = combineWithAllErrors;
})(Result || (Result = {}));
var ok = (value) => new Ok(value);
function err(err2) {
  return new Err(err2);
}
var Ok = class {
  constructor(value) {
    this.value = value;
  }
  isOk() {
    return true;
  }
  isErr() {
    return !this.isOk();
  }
  map(f) {
    return ok(f(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  mapErr(_f) {
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f) {
    return f(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThrough(f) {
    return f(this.value).map((_value) => this.value);
  }
  andTee(f) {
    try {
      f(this.value);
    } catch (e) {
    }
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(_f) {
    return ok(this.value);
  }
  asyncAndThen(f) {
    return f(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  asyncAndThrough(f) {
    return f(this.value).map(() => this.value);
  }
  asyncMap(f) {
    return ResultAsync.fromSafePromise(f(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unwrapOr(_v) {
    return this.value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  match(ok2, _err) {
    return ok2(this.value);
  }
  safeUnwrap() {
    const value = this.value;
    return (function* () {
      return value;
    })();
  }
  _unsafeUnwrap(_) {
    return this.value;
  }
  _unsafeUnwrapErr(config) {
    throw createNeverThrowError("Called `_unsafeUnwrapErr` on an Ok", this, config);
  }
};
var Err = class {
  constructor(error) {
    this.error = error;
  }
  isOk() {
    return false;
  }
  isErr() {
    return !this.isOk();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_f) {
    return err(this.error);
  }
  mapErr(f) {
    return err(f(this.error));
  }
  andThrough(_f) {
    return err(this.error);
  }
  andTee(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f) {
    return f(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncAndThen(_f) {
    return errAsync(this.error);
  }
  asyncAndThrough(_f) {
    return errAsync(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncMap(_f) {
    return errAsync(this.error);
  }
  unwrapOr(v) {
    return v;
  }
  match(_ok, err2) {
    return err2(this.error);
  }
  safeUnwrap() {
    const error = this.error;
    return (function* () {
      yield err(error);
      throw new Error("Do not use this generator out of `safeTry`");
    })();
  }
  _unsafeUnwrap(config) {
    throw createNeverThrowError("Called `_unsafeUnwrap` on an Err", this, config);
  }
  _unsafeUnwrapErr(_) {
    return this.error;
  }
};
var fromThrowable = Result.fromThrowable;

// src/types.ts
var StepTypes = [
  "Initial",
  "Run",
  "SleepFor",
  "SleepUntil",
  "Call",
  "Wait",
  "Notify",
  "Invoke",
  "CreateWebhook",
  "WaitForWebhook"
];

// src/workflow-requests.ts
var import_qstash3 = require("@upstash/qstash");
var triggerFirstInvocation = async (params) => {
  const firstInvocationParams = Array.isArray(params) ? params : [params];
  const workflowContextClient = firstInvocationParams[0].workflowContext.qstashClient;
  const invocationBatch = firstInvocationParams.map(
    ({
      workflowContext,
      useJSONContent,
      telemetry: telemetry2,
      invokeCount,
      delay,
      notBefore,
      failureUrl,
      retries,
      retryDelay,
      flowControl,
      unknownSdk
    }) => {
      const { headers } = getHeaders({
        initHeaderValue: "true",
        workflowConfig: {
          workflowRunId: workflowContext.workflowRunId,
          workflowUrl: workflowContext.url,
          failureUrl,
          retries,
          retryDelay,
          telemetry: telemetry2,
          flowControl,
          useJSONContent: useJSONContent ?? false
        },
        invokeCount: invokeCount ?? 0,
        userHeaders: workflowContext.headers
      });
      if (workflowContext.headers.get("content-type")) {
        headers["content-type"] = workflowContext.headers.get("content-type");
      }
      if (useJSONContent) {
        headers["content-type"] = "application/json";
      }
      if (unknownSdk) {
        headers[WORKFLOW_UNKOWN_SDK_TRIGGER_HEADER] = "true";
      }
      if (workflowContext.label) {
        headers[WORKFLOW_LABEL_HEADER] = workflowContext.label;
      }
      const body = typeof workflowContext.requestPayload === "string" ? workflowContext.requestPayload : JSON.stringify(workflowContext.requestPayload);
      return {
        headers,
        method: "POST",
        body,
        url: workflowContext.url,
        delay,
        notBefore
      };
    }
  );
  try {
    const results = await workflowContextClient.batch(invocationBatch);
    const invocationStatuses = [];
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const invocationParams = firstInvocationParams[i];
      invocationParams.middlewareManager?.assignContext(invocationParams.workflowContext);
      if (result.deduplicated) {
        await invocationParams.middlewareManager?.dispatchDebug("onWarning", {
          warning: `Workflow run ${invocationParams.workflowContext.workflowRunId} already exists. A new one isn't created.`
        });
        invocationStatuses.push("workflow-run-already-exists");
      } else {
        await invocationParams.middlewareManager?.dispatchDebug("onInfo", {
          info: `Workflow run started successfully with URL ${invocationParams.workflowContext.url}.`
        });
        invocationStatuses.push("success");
      }
    }
    const hasAnyDeduplicated = invocationStatuses.some(
      (status) => status === "workflow-run-already-exists"
    );
    if (hasAnyDeduplicated) {
      return ok("workflow-run-already-exists");
    } else {
      return ok("success");
    }
  } catch (error) {
    const error_ = error;
    return err(error_);
  }
};
var triggerRouteFunction = async ({
  onCleanup,
  onStep,
  onCancel,
  middlewareManager
}) => {
  try {
    const result = await onStep();
    await onCleanup(result);
    return ok("workflow-finished");
  } catch (error) {
    const error_ = error;
    if (isInstanceOf(error, import_qstash3.QstashError) && error.status === 400) {
      await middlewareManager?.dispatchDebug("onWarning", {
        warning: `Tried to append to a cancelled workflow. Exiting without publishing. Error: ${error.message}`
      });
      return ok("workflow-was-finished");
    } else if (isInstanceOf(error_, WorkflowNonRetryableError) || isInstanceOf(error_, WorkflowRetryAfterError)) {
      return ok(error_);
    } else if (isInstanceOf(error_, WorkflowCancelAbort)) {
      await onCancel();
      return ok("workflow-finished");
    } else if (isInstanceOf(error_, WorkflowAbort)) {
      return ok("step-finished");
    } else {
      return err(error_);
    }
  }
};
var triggerWorkflowDelete = async (workflowContext, result, cancel = false, dispatchDebug) => {
  await dispatchDebug?.("onInfo", {
    info: `Deleting workflow run ${workflowContext.workflowRunId} from QStash` + (cancel ? " with cancel=true." : ".")
  });
  await workflowContext.qstashClient.http.request({
    path: ["v2", "workflows", "runs", `${workflowContext.workflowRunId}?cancel=${cancel}`],
    method: "DELETE",
    parseResponseAsJson: false,
    body: JSON.stringify(result)
  });
  await dispatchDebug?.("onInfo", {
    info: `Workflow run ${workflowContext.workflowRunId} deleted from QStash successfully.`
  });
};
var recreateUserHeaders = (headers) => {
  const filteredHeaders = new Headers();
  const pairs = headers.entries();
  for (const [header, value] of pairs) {
    const headerLowerCase = header.toLowerCase();
    const isUserHeader = headerLowerCase !== "upstash-region" && !headerLowerCase.startsWith("upstash-workflow-") && // https://vercel.com/docs/edge-network/headers/request-headers#x-vercel-id
    !headerLowerCase.startsWith("x-vercel-") && !headerLowerCase.startsWith("x-forwarded-") && // https://blog.cloudflare.com/preventing-request-loops-using-cdn-loop/
    headerLowerCase !== "cf-connecting-ip" && headerLowerCase !== "cdn-loop" && headerLowerCase !== "cf-ew-via" && headerLowerCase !== "cf-ray" && // For Render https://render.com
    headerLowerCase !== "render-proxy-ttl" || headerLowerCase === WORKFLOW_LABEL_HEADER.toLocaleLowerCase();
    if (isUserHeader) {
      filteredHeaders.append(header, value);
    }
  }
  return filteredHeaders;
};
var handleThirdPartyCallResult = async ({
  request,
  requestPayload,
  client,
  workflowUrl,
  telemetry: telemetry2,
  middlewareManager
}) => {
  try {
    if (request.headers.get("Upstash-Workflow-Callback")) {
      let callbackPayload;
      if (requestPayload) {
        callbackPayload = requestPayload;
      } else {
        const workflowRunId2 = request.headers.get("upstash-workflow-runid");
        const messageId = request.headers.get("upstash-message-id");
        if (!workflowRunId2)
          throw new WorkflowError("workflow run id missing in context.call lazy fetch.");
        if (!messageId) throw new WorkflowError("message id missing in context.call lazy fetch.");
        const { steps, workflowRunEnded } = await getSteps(
          client.http,
          workflowRunId2,
          messageId,
          middlewareManager?.dispatchDebug.bind(middlewareManager)
        );
        if (workflowRunEnded) {
          return ok("workflow-ended");
        }
        const failingStep = steps.find((step) => step.messageId === messageId);
        if (!failingStep)
          throw new WorkflowError(
            "Failed to submit the context.call. " + (steps.length === 0 ? "No steps found." : `No step was found with matching messageId ${messageId} out of ${steps.length} steps.`)
          );
        callbackPayload = atob(failingStep.body);
      }
      const callbackMessage = JSON.parse(callbackPayload);
      if (!(callbackMessage.status >= 200 && callbackMessage.status < 300) && callbackMessage.maxRetries && callbackMessage.retried !== callbackMessage.maxRetries) {
        await middlewareManager?.dispatchDebug("onWarning", {
          warning: `Third party call returned status ${callbackMessage.status}. Retrying (${callbackMessage.retried} out of ${callbackMessage.maxRetries}).`
        });
        console.warn(
          `Workflow Warning: "context.call" failed with status ${callbackMessage.status} and will retry (retried ${callbackMessage.retried ?? 0} out of ${callbackMessage.maxRetries} times). Error Message:
${atob(callbackMessage.body ?? "")}`
        );
        return ok("call-will-retry");
      }
      const workflowRunId = request.headers.get(WORKFLOW_ID_HEADER);
      const stepIdString = request.headers.get("Upstash-Workflow-StepId");
      const stepName = request.headers.get("Upstash-Workflow-StepName");
      const stepType = request.headers.get("Upstash-Workflow-StepType");
      const concurrentString = request.headers.get("Upstash-Workflow-Concurrent");
      const contentType = request.headers.get("Upstash-Workflow-ContentType");
      const invokeCount = request.headers.get(WORKFLOW_INVOKE_COUNT_HEADER);
      if (!(workflowRunId && stepIdString && stepName && StepTypes.includes(stepType) && concurrentString && contentType)) {
        throw new Error(
          `Missing info in callback message source header: ${JSON.stringify({
            workflowRunId,
            stepIdString,
            stepName,
            stepType,
            concurrentString,
            contentType
          })}`
        );
      }
      const userHeaders = recreateUserHeaders(request.headers);
      const { headers: requestHeaders } = getHeaders({
        initHeaderValue: "false",
        workflowConfig: {
          workflowRunId,
          workflowUrl,
          telemetry: telemetry2
        },
        userHeaders,
        invokeCount: Number(invokeCount)
      });
      const callResponse = {
        status: callbackMessage.status,
        body: atob(callbackMessage.body ?? ""),
        header: callbackMessage.header
      };
      const callResultStep = {
        stepId: Number(stepIdString),
        stepName,
        stepType,
        out: JSON.stringify(callResponse),
        concurrent: Number(concurrentString)
      };
      await middlewareManager?.dispatchDebug("onInfo", {
        info: `Submitting third party call result, step ${stepName} (${stepIdString}).`
      });
      await client.publishJSON({
        headers: requestHeaders,
        method: "POST",
        body: callResultStep,
        url: workflowUrl
      });
      await middlewareManager?.dispatchDebug("onInfo", {
        info: `Third party call result submitted successfully, step ${stepName} (${stepIdString}).`
      });
      return ok("is-call-return");
    } else {
      return ok("continue-workflow");
    }
  } catch (error) {
    const isCallReturn = request.headers.get("Upstash-Workflow-Callback");
    return err(
      new WorkflowError(`Error when handling call return (isCallReturn=${isCallReturn}): ${error}`)
    );
  }
};
var getTelemetryHeaders = (telemetry2) => {
  return {
    [TELEMETRY_HEADER_SDK]: telemetry2.sdk,
    [TELEMETRY_HEADER_FRAMEWORK]: telemetry2.framework ?? "unknown",
    [TELEMETRY_HEADER_RUNTIME]: telemetry2.runtime ?? "unknown"
  };
};
var verifyRequest = async (body, signature, verifier) => {
  if (!verifier) {
    return;
  }
  try {
    if (!signature) {
      throw new Error("`Upstash-Signature` header is not passed.");
    }
    const isValid = await verifier.verify({
      body,
      signature
    });
    if (!isValid) {
      throw new Error("Signature in `Upstash-Signature` header is not valid");
    }
  } catch (error) {
    throw new WorkflowError(
      `Failed to verify that the Workflow request comes from QStash: ${error}

If signature is missing, trigger the workflow endpoint by publishing your request to QStash instead of calling it directly.

If you want to disable QStash Verification, you should clear env variables QSTASH_CURRENT_SIGNING_KEY and QSTASH_NEXT_SIGNING_KEY`
    );
  }
};

// src/context/steps.ts
var BaseLazyStep = class _BaseLazyStep {
  stepName;
  context;
  constructor(context, stepName) {
    this.context = context;
    if (!stepName) {
      throw new WorkflowError(
        "A workflow step name cannot be undefined or an empty string. Please provide a name for your workflow step."
      );
    }
    if (typeof stepName !== "string") {
      throw new WorkflowError(
        `A workflow step name must be a string. Received "${stepName}" (${typeof stepName}).`
      );
    }
    this.stepName = stepName;
  }
  /**
   * parse the out field of a step result.
   *
   * will be called when returning the steps to the context from auto executor
   *
   * @param step step
   * @returns parsed out field
   */
  parseOut(step) {
    const out = step.out;
    if (out === void 0) {
      if (this.allowUndefinedOut) {
        return this.handleUndefinedOut(step);
      } else {
        throw new WorkflowError(
          `Error while parsing output of ${this.stepType} step. Expected a string, but got: undefined`
        );
      }
    }
    if (typeof out === "object") {
      console.warn(
        `Error while parsing ${this.stepType} step output. Expected a string, but got object. Please reach out to Upstash Support.`
      );
      return out;
    }
    if (typeof out !== "string") {
      throw new WorkflowError(
        `Error while parsing output of ${this.stepType} step. Expected a string or undefined, but got: ${typeof out}`
      );
    }
    return this.safeParseOut(out, step);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  safeParseOut(out, step) {
    return _BaseLazyStep.tryParsing(out);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleUndefinedOut(step) {
    return void 0;
  }
  static tryParsing(stepOut) {
    try {
      return JSON.parse(stepOut);
    } catch {
      return stepOut;
    }
  }
  getBody({ step }) {
    step.out = JSON.stringify(step.out);
    return JSON.stringify(step);
  }
  getHeaders({ context, telemetry: telemetry2, invokeCount, step }) {
    return getHeaders({
      initHeaderValue: "false",
      workflowConfig: {
        workflowRunId: context.workflowRunId,
        workflowUrl: context.url,
        useJSONContent: false,
        telemetry: telemetry2
      },
      userHeaders: context.headers,
      invokeCount,
      stepInfo: {
        step,
        lazyStep: this
      }
    });
  }
  async submitStep({ context, body, headers }) {
    return await context.qstashClient.batch([
      {
        body,
        headers,
        method: "POST",
        url: context.url
      }
    ]);
  }
};
var LazyFunctionStep = class extends BaseLazyStep {
  stepFunction;
  stepType = "Run";
  allowUndefinedOut = true;
  constructor(context, stepName, stepFunction) {
    super(context, stepName);
    this.stepFunction = stepFunction;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    let result = this.stepFunction();
    if (result instanceof Promise) {
      result = await result;
    }
    return {
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      out: result,
      concurrent
    };
  }
};
var LazySleepStep = class extends BaseLazyStep {
  sleep;
  stepType = "SleepFor";
  allowUndefinedOut = true;
  constructor(context, stepName, sleep) {
    super(context, stepName);
    this.sleep = sleep;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      sleepFor: this.sleep,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    return await Promise.resolve({
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      sleepFor: this.sleep,
      concurrent
    });
  }
  async submitStep({ context, body, headers, isParallel }) {
    return await context.qstashClient.batch([
      {
        body,
        headers,
        method: "POST",
        url: context.url,
        delay: isParallel ? void 0 : this.sleep
      }
    ]);
  }
};
var LazySleepUntilStep = class extends BaseLazyStep {
  sleepUntil;
  stepType = "SleepUntil";
  allowUndefinedOut = true;
  constructor(context, stepName, sleepUntil) {
    super(context, stepName);
    this.sleepUntil = sleepUntil;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      sleepUntil: this.sleepUntil,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    return await Promise.resolve({
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      sleepUntil: this.sleepUntil,
      concurrent
    });
  }
  safeParseOut() {
    return void 0;
  }
  async submitStep({ context, body, headers, isParallel }) {
    return await context.qstashClient.batch([
      {
        body,
        headers,
        method: "POST",
        url: context.url,
        notBefore: isParallel ? void 0 : this.sleepUntil
      }
    ]);
  }
};
var LazyCallStep = class _LazyCallStep extends BaseLazyStep {
  url;
  method;
  body;
  headers;
  retries;
  retryDelay;
  timeout;
  flowControl;
  stepType = "Call";
  allowUndefinedOut = false;
  constructor(params) {
    super(params.context, params.stepName);
    this.url = params.url;
    this.method = params.method ?? "GET";
    this.body = params.body;
    this.headers = params.headers ?? {};
    this.retries = params.retries ?? 0;
    this.retryDelay = params.retryDelay;
    this.timeout = params.timeout;
    this.flowControl = params.flowControl;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    return await Promise.resolve({
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent,
      callUrl: this.url,
      callMethod: this.method,
      callBody: this.body,
      callHeaders: this.headers
    });
  }
  safeParseOut(out) {
    const { header, status, body } = JSON.parse(out);
    const responseHeaders = new Headers(header);
    if (_LazyCallStep.isText(responseHeaders.get("content-type"))) {
      const bytes = new Uint8Array(out.length);
      for (let i = 0; i < out.length; i++) {
        bytes[i] = out.charCodeAt(i);
      }
      const processedResult = new TextDecoder().decode(bytes);
      const newBody = JSON.parse(processedResult).body;
      return {
        status,
        header,
        body: BaseLazyStep.tryParsing(newBody)
      };
    } else {
      return { header, status, body };
    }
  }
  static applicationContentTypes = [
    "application/json",
    "application/xml",
    "application/javascript",
    "application/x-www-form-urlencoded",
    "application/xhtml+xml",
    "application/ld+json",
    "application/rss+xml",
    "application/atom+xml"
  ];
  static isText = (contentTypeHeader) => {
    if (!contentTypeHeader) {
      return false;
    }
    if (_LazyCallStep.applicationContentTypes.some((type) => contentTypeHeader.includes(type))) {
      return true;
    }
    if (contentTypeHeader.startsWith("text/")) {
      return true;
    }
    return false;
  };
  getBody({ step }) {
    if (!step.callUrl) {
      throw new WorkflowError("Incompatible step received in LazyCallStep.getBody");
    }
    return JSON.stringify(step.callBody);
  }
  getHeaders({ context, telemetry: telemetry2, invokeCount, step }) {
    const { headers, contentType } = super.getHeaders({ context, telemetry: telemetry2, invokeCount, step });
    headers["Upstash-Retries"] = this.retries.toString();
    if (this.retryDelay) {
      headers["Upstash-Retry-Delay"] = this.retryDelay;
    }
    headers[WORKFLOW_FEATURE_HEADER] = "WF_NoDelete,InitialBody";
    if (this.flowControl) {
      const { flowControlKey, flowControlValue } = prepareFlowControl(this.flowControl);
      headers["Upstash-Flow-Control-Key"] = flowControlKey;
      headers["Upstash-Flow-Control-Value"] = flowControlValue;
    }
    if (this.timeout) {
      headers["Upstash-Timeout"] = this.timeout.toString();
    }
    const forwardedHeaders = Object.fromEntries(
      Object.entries(this.headers).map(([header, value]) => [`Upstash-Forward-${header}`, value])
    );
    return {
      headers: {
        ...headers,
        ...forwardedHeaders,
        "Upstash-Callback": context.url,
        "Upstash-Callback-Workflow-RunId": context.workflowRunId,
        "Upstash-Callback-Workflow-CallType": "fromCallback",
        "Upstash-Callback-Workflow-Init": "false",
        "Upstash-Callback-Workflow-Url": context.url,
        "Upstash-Callback-Feature-Set": "LazyFetch,InitialBody,WF_DetectTrigger,WF_TriggerOnConfig",
        "Upstash-Callback-Forward-Upstash-Workflow-Callback": "true",
        "Upstash-Callback-Forward-Upstash-Workflow-StepId": step.stepId.toString(),
        "Upstash-Callback-Forward-Upstash-Workflow-StepName": this.stepName,
        "Upstash-Callback-Forward-Upstash-Workflow-StepType": this.stepType,
        "Upstash-Callback-Forward-Upstash-Workflow-Concurrent": step.concurrent.toString(),
        "Upstash-Callback-Forward-Upstash-Workflow-ContentType": contentType,
        "Upstash-Workflow-CallType": "toCallback"
      },
      contentType
    };
  }
  async submitStep({ context, headers }) {
    return await context.qstashClient.batch([
      {
        headers,
        body: this.body,
        method: this.method,
        url: this.url,
        retries: DEFAULT_RETRIES === this.retries ? void 0 : this.retries,
        retryDelay: this.retryDelay,
        flowControl: this.flowControl
      }
    ]);
  }
};
var LazyWaitEventStep = class extends BaseLazyStep {
  eventId;
  timeout;
  allowUndefinedOut = false;
  constructor(context, stepName, eventId, timeout) {
    super(context, stepName);
    this.eventId = eventId;
    this.timeout = timeout;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      waitEventId: this.eventId,
      timeout: this.timeout,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    return await Promise.resolve({
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      waitEventId: this.eventId,
      timeout: this.timeout,
      concurrent
    });
  }
  getHeaders({ context, telemetry: telemetry2, invokeCount, step }) {
    const headers = super.getHeaders({ context, telemetry: telemetry2, invokeCount, step });
    headers.headers["Upstash-Workflow-CallType"] = "step";
    return headers;
  }
  getBody({ context, step, headers, telemetry: telemetry2 }) {
    if (!step.waitEventId) {
      throw new WorkflowError("Incompatible step received in LazyWaitForEventStep.getBody");
    }
    const timeoutHeaders = {
      // to include user headers:
      ...Object.fromEntries(Object.entries(headers).map(([header, value]) => [header, [value]])),
      // to include telemetry headers:
      ...telemetry2 ? Object.fromEntries(
        Object.entries(getTelemetryHeaders(telemetry2)).map(([header, value]) => [
          header,
          [value]
        ])
      ) : {},
      // note: using WORKFLOW_ID_HEADER doesn't work, because Runid -> RunId:
      "Upstash-Workflow-Runid": [context.workflowRunId],
      [WORKFLOW_INIT_HEADER]: ["false"],
      [WORKFLOW_URL_HEADER]: [context.url],
      "Upstash-Workflow-CallType": ["step"]
    };
    const waitBody = {
      url: context.url,
      timeout: step.timeout,
      timeoutBody: void 0,
      timeoutUrl: context.url,
      timeoutHeaders,
      step: {
        stepId: step.stepId,
        stepType: this.stepType,
        stepName: step.stepName,
        concurrent: step.concurrent,
        targetStep: step.targetStep
      }
    };
    return JSON.stringify(waitBody);
  }
  async submitStep({ context, body, headers }) {
    const result = await context.qstashClient.http.request({
      path: ["v2", "wait", this.eventId],
      body,
      headers,
      method: "POST",
      parseResponseAsJson: false
    });
    return [result];
  }
};
var LazyNotifyStep = class extends LazyFunctionStep {
  stepType = "Notify";
  constructor(context, stepName, eventId, eventData, requester) {
    super(context, stepName, async () => {
      const notifyResponse = await makeNotifyRequest(requester, eventId, eventData);
      return {
        eventId,
        eventData,
        notifyResponse
      };
    });
  }
  safeParseOut(out) {
    const result = JSON.parse(out);
    return {
      ...result,
      eventData: BaseLazyStep.tryParsing(result.eventData)
    };
  }
};
var LazyInvokeStep = class extends BaseLazyStep {
  stepType = "Invoke";
  params;
  allowUndefinedOut = false;
  /**
   * workflow id of the invoked workflow
   */
  workflowId;
  constructor(context, stepName, params) {
    super(context, stepName);
    this.params = params;
    const { workflowId } = params.workflow;
    if (!workflowId) {
      throw new WorkflowError("You can only invoke workflow which has a workflowId");
    }
    this.workflowId = workflowId;
  }
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent,
      targetStep
    };
  }
  /**
   * won't be used as it's the server who will add the result step
   * in Invoke step.
   */
  getResultStep(concurrent, stepId) {
    return Promise.resolve({
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent
    });
  }
  safeParseOut(out) {
    const result = JSON.parse(out);
    return {
      ...result,
      body: BaseLazyStep.tryParsing(result.body)
    };
  }
  getBody({ context, step, telemetry: telemetry2, invokeCount }) {
    const { headers: invokerHeaders } = getHeaders({
      initHeaderValue: "false",
      workflowConfig: {
        workflowRunId: context.workflowRunId,
        workflowUrl: context.url,
        telemetry: telemetry2,
        useJSONContent: false
      },
      userHeaders: context.headers,
      invokeCount
    });
    context.qstashClient.http.headers?.forEach((value, key) => {
      invokerHeaders[key] = value;
    });
    invokerHeaders["Upstash-Workflow-Runid"] = context.workflowRunId;
    const request = {
      body: stringifyBody(this.params.body),
      headers: Object.fromEntries(
        Object.entries(invokerHeaders).map((pairs) => [pairs[0], [pairs[1]]])
      ),
      workflowRunId: context.workflowRunId,
      workflowRunCreatedAt: context.workflowRunCreatedAt,
      workflowUrl: context.url,
      step
    };
    return JSON.stringify(request);
  }
  getHeaders({ context, telemetry: telemetry2, invokeCount }) {
    const {
      workflow,
      headers = {},
      workflowRunId,
      retries,
      retryDelay,
      flowControl,
      label
    } = this.params;
    const newUrl = context.url.replace(/[^/]+$/, this.workflowId);
    const { headers: triggerHeaders, contentType } = getHeaders({
      initHeaderValue: "true",
      workflowConfig: {
        workflowRunId: getWorkflowRunId(workflowRunId),
        workflowUrl: newUrl,
        retries,
        retryDelay,
        telemetry: telemetry2,
        failureUrl: newUrl,
        flowControl,
        useJSONContent: workflow.useJSONContent ?? false
      },
      invokeCount: invokeCount + 1,
      userHeaders: new Headers(headers)
    });
    triggerHeaders["Upstash-Workflow-Invoke"] = "true";
    if (label) {
      triggerHeaders[WORKFLOW_LABEL_HEADER] = label;
      triggerHeaders[`upstash-forward-${WORKFLOW_LABEL_HEADER}`] = label;
    }
    return { headers: triggerHeaders, contentType };
  }
  async submitStep({ context, body, headers }) {
    const newUrl = context.url.replace(/[^/]+$/, this.workflowId);
    const result = await context.qstashClient.publish({
      headers,
      method: "POST",
      body,
      url: newUrl
    });
    return [result];
  }
};
var LazyCreateWebhookStep = class extends BaseLazyStep {
  stepType = "CreateWebhook";
  allowUndefinedOut = false;
  getPlanStep(concurrent, targetStep) {
    return {
      stepId: 0,
      stepName: this.stepName,
      stepType: this.stepType,
      concurrent,
      targetStep
    };
  }
  async getResultStep(concurrent, stepId) {
    return {
      stepId,
      stepName: this.stepName,
      stepType: this.stepType,
      out: void 0,
      concurrent
    };
  }
  getBody({ step, context }) {
    const userId = getUserIdFromToken(context.qstashClient);
    const workflowRunId = context.workflowRunId;
    const eventId = getEventId();
    const qstashUrl = getQStashUrl(this.context.qstashClient);
    return JSON.stringify({
      ...step,
      out: JSON.stringify({
        webhookUrl: `${qstashUrl}/v2/workflows/hooks/${userId}/${workflowRunId}/${eventId}`,
        eventId
      })
    });
  }
};
var LazyWaitForWebhookStep = class extends LazyWaitEventStep {
  stepType = "WaitForWebhook";
  allowUndefinedOut = true;
  constructor(context, stepName, webhook, timeout) {
    super(context, stepName, webhook.eventId, timeout);
  }
  safeParseOut(out) {
    const eventData = decodeBase64(out);
    const parsedEventData = BaseLazyStep.tryParsing(eventData);
    const body = parsedEventData.body;
    const parsedBody = typeof body === "string" ? decodeBase64(body) : void 0;
    const request = new Request(
      `${parsedEventData.proto}://${parsedEventData.host}${parsedEventData.url}`,
      {
        method: parsedEventData.method,
        headers: parsedEventData.header,
        body: parsedBody
      }
    );
    return {
      request,
      timeout: false
    };
  }
  handleUndefinedOut() {
    return {
      timeout: true,
      request: void 0
    };
  }
};
var LazyWaitForEventStep = class extends LazyWaitEventStep {
  stepType = "Wait";
  allowUndefinedOut = true;
  parseWaitForEventOut(out, waitTimeout) {
    return {
      eventData: out ? BaseLazyStep.tryParsing(decodeBase64(out)) : void 0,
      timeout: waitTimeout ?? false
    };
  }
  safeParseOut(out, step) {
    return this.parseWaitForEventOut(out, step.waitTimeout);
  }
  handleUndefinedOut(step) {
    return this.parseWaitForEventOut(void 0, step.waitTimeout);
  }
};

// src/qstash/headers.ts
var WorkflowHeaders = class {
  userHeaders;
  workflowConfig;
  invokeCount;
  initHeaderValue;
  stepInfo;
  headers;
  /**
   * @param params workflow header parameters
   */
  constructor({
    userHeaders,
    workflowConfig,
    invokeCount,
    initHeaderValue,
    stepInfo
  }) {
    this.userHeaders = userHeaders;
    this.workflowConfig = workflowConfig;
    this.invokeCount = invokeCount;
    this.initHeaderValue = initHeaderValue;
    this.stepInfo = stepInfo;
    this.headers = {
      rawHeaders: {},
      workflowHeaders: {},
      failureHeaders: {}
    };
  }
  getHeaders() {
    this.addBaseHeaders();
    this.addRetries();
    this.addRetryDelay();
    this.addFlowControl();
    this.addUserHeaders();
    this.addInvokeCount();
    this.addFailureUrl();
    const contentType = this.addContentType();
    return this.prefixHeaders(contentType);
  }
  addBaseHeaders() {
    this.headers.rawHeaders = {
      ...this.headers.rawHeaders,
      [WORKFLOW_INIT_HEADER]: this.initHeaderValue,
      [WORKFLOW_ID_HEADER]: this.workflowConfig.workflowRunId,
      [WORKFLOW_URL_HEADER]: this.workflowConfig.workflowUrl,
      [WORKFLOW_FEATURE_HEADER]: "LazyFetch,InitialBody,WF_DetectTrigger,WF_TriggerOnConfig",
      [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION,
      ...this.workflowConfig.telemetry ? getTelemetryHeaders(this.workflowConfig.telemetry) : {}
    };
    if (this.stepInfo?.lazyStep.stepType !== "Call") {
      this.headers.rawHeaders[`Upstash-Forward-${WORKFLOW_PROTOCOL_VERSION_HEADER}`] = WORKFLOW_PROTOCOL_VERSION;
    }
  }
  addInvokeCount() {
    if (this.invokeCount === void 0 || this.invokeCount === 0) {
      return;
    }
    const invokeCount = this.invokeCount.toString();
    this.headers.workflowHeaders[`Forward-${WORKFLOW_INVOKE_COUNT_HEADER}`] = invokeCount;
    if (this.workflowConfig.failureUrl) {
      this.headers.failureHeaders[`Forward-${WORKFLOW_INVOKE_COUNT_HEADER}`] = invokeCount;
    }
    if (this.stepInfo?.lazyStep instanceof LazyCallStep) {
      this.headers.rawHeaders[`Upstash-Forward-${WORKFLOW_INVOKE_COUNT_HEADER}`] = invokeCount;
    }
  }
  addRetries() {
    if (this.workflowConfig.retries === void 0 || this.workflowConfig.retries === DEFAULT_RETRIES) {
      return;
    }
    const retries = this.workflowConfig.retries.toString();
    this.headers.workflowHeaders["Retries"] = retries;
    if (this.workflowConfig.failureUrl) {
      this.headers.failureHeaders["Retries"] = retries;
    }
  }
  addRetryDelay() {
    if (this.workflowConfig.retryDelay === void 0 || this.workflowConfig.retryDelay === "") {
      return;
    }
    const retryDelay = this.workflowConfig.retryDelay.toString();
    this.headers.workflowHeaders["Retry-Delay"] = retryDelay;
    if (this.workflowConfig.failureUrl) {
      this.headers.failureHeaders["Retry-Delay"] = retryDelay;
    }
  }
  addFlowControl() {
    if (!this.workflowConfig.flowControl) {
      return;
    }
    const { flowControlKey, flowControlValue } = prepareFlowControl(
      this.workflowConfig.flowControl
    );
    this.headers.workflowHeaders["Flow-Control-Key"] = flowControlKey;
    this.headers.workflowHeaders["Flow-Control-Value"] = flowControlValue;
    if (this.workflowConfig.failureUrl) {
      this.headers.failureHeaders["Flow-Control-Key"] = flowControlKey;
      this.headers.failureHeaders["Flow-Control-Value"] = flowControlValue;
    }
  }
  addUserHeaders() {
    for (const [key, value] of this.userHeaders.entries()) {
      const forwardKey = `Forward-${key}`;
      this.headers.workflowHeaders[forwardKey] = value;
      if (this.workflowConfig.failureUrl) {
        this.headers.failureHeaders[forwardKey] = value;
      }
    }
  }
  addFailureUrl() {
    if (!this.workflowConfig.failureUrl) {
      return;
    }
    this.headers.workflowHeaders["Failure-Callback"] = this.workflowConfig.failureUrl;
    this.headers.failureHeaders[`Forward-${WORKFLOW_FAILURE_HEADER}`] = "true";
    this.headers.failureHeaders[`Forward-${WORKFLOW_FAILURE_CALLBACK_HEADER}`] = "true";
    this.headers.failureHeaders["Workflow-Runid"] = this.workflowConfig.workflowRunId;
    this.headers.failureHeaders["Workflow-Init"] = "false";
    this.headers.failureHeaders["Workflow-Url"] = this.workflowConfig.workflowUrl;
    this.headers.failureHeaders["Workflow-Calltype"] = "failureCall";
    this.headers.failureHeaders["Feature-Set"] = "LazyFetch,InitialBody,WF_DetectTrigger,WF_TriggerOnConfig";
    if (this.workflowConfig.retries !== void 0 && this.workflowConfig.retries !== DEFAULT_RETRIES) {
      this.headers.failureHeaders["Retries"] = this.workflowConfig.retries.toString();
    }
    if (this.workflowConfig.retryDelay !== void 0 && this.workflowConfig.retryDelay !== "") {
      this.headers.failureHeaders["Retry-Delay"] = this.workflowConfig.retryDelay.toString();
    }
  }
  addContentType() {
    if (this.workflowConfig.useJSONContent) {
      this.headers.rawHeaders["content-type"] = "application/json";
      return "application/json";
    }
    const callHeaders = new Headers(
      this.stepInfo?.lazyStep instanceof LazyCallStep ? this.stepInfo.lazyStep.headers : {}
    );
    const contentType = (callHeaders.get("content-type") ? callHeaders.get("content-type") : this.userHeaders?.get("Content-Type") ? this.userHeaders.get("Content-Type") : void 0) ?? DEFAULT_CONTENT_TYPE;
    this.headers.rawHeaders["content-type"] = contentType;
    return contentType;
  }
  prefixHeaders(contentType) {
    const { rawHeaders, workflowHeaders, failureHeaders } = this.headers;
    const isCall = this.stepInfo?.lazyStep.stepType === "Call";
    return {
      headers: {
        ...rawHeaders,
        ...addPrefixToHeaders(workflowHeaders, isCall ? "Upstash-Callback-" : "Upstash-"),
        ...addPrefixToHeaders(failureHeaders, "Upstash-Failure-Callback-"),
        ...isCall ? addPrefixToHeaders(failureHeaders, "Upstash-Callback-Failure-Callback-") : {}
      },
      contentType
    };
  }
};
function addPrefixToHeaders(headers, prefix) {
  const prefixedHeaders = {};
  for (const [key, value] of Object.entries(headers)) {
    prefixedHeaders[`${prefix}${key}`] = value;
  }
  return prefixedHeaders;
}
var prepareFlowControl = (flowControl) => {
  const parallelism = flowControl.parallelism?.toString();
  const rate = (flowControl.rate ?? flowControl.ratePerSecond)?.toString();
  const period = typeof flowControl.period === "number" ? `${flowControl.period}s` : flowControl.period;
  const controlValue = [
    parallelism ? `parallelism=${parallelism}` : void 0,
    rate ? `rate=${rate}` : void 0,
    period ? `period=${period}` : void 0
  ].filter(Boolean);
  if (controlValue.length === 0) {
    throw new import_qstash4.QstashError("Provide at least one of parallelism or ratePerSecond for flowControl");
  }
  return {
    flowControlKey: flowControl.key,
    flowControlValue: controlValue.join(", ")
  };
};
var getHeaders = (params) => {
  const workflowHeaders = new WorkflowHeaders(params);
  return workflowHeaders.getHeaders();
};

// src/qstash/submit-steps.ts
var submitParallelSteps = async ({
  context,
  steps,
  initialStepCount,
  invokeCount,
  telemetry: telemetry2,
  dispatchDebug
}) => {
  const planSteps = steps.map(
    (step, index) => step.getPlanStep(steps.length, initialStepCount + index)
  );
  await dispatchDebug("onInfo", {
    info: `Submitting ${planSteps.length} parallel steps.`
  });
  const result = await context.qstashClient.batch(
    planSteps.map((planStep) => {
      const { headers } = getHeaders({
        initHeaderValue: "false",
        workflowConfig: {
          workflowRunId: context.workflowRunId,
          workflowUrl: context.url,
          telemetry: telemetry2
        },
        userHeaders: context.headers,
        invokeCount
      });
      return {
        headers,
        method: "POST",
        url: context.url,
        body: JSON.stringify(planStep),
        notBefore: planStep.sleepUntil,
        delay: planStep.sleepFor
      };
    })
  );
  if (result && result.length > 0) {
    await dispatchDebug("onInfo", {
      info: `Submitted ${planSteps.length} parallel steps. messageIds: ${result.filter((r) => r).map((r) => r.messageId).join(", ")}.`
    });
  }
  throw new WorkflowAbort(planSteps[0].stepName, planSteps[0]);
};
var submitSingleStep = async ({
  context,
  lazyStep,
  stepId,
  invokeCount,
  concurrency,
  telemetry: telemetry2,
  dispatchDebug,
  dispatchLifecycle
}) => {
  await dispatchLifecycle("beforeExecution", {
    stepName: lazyStep.stepName
  });
  const resultStep = await lazyStep.getResultStep(concurrency, stepId);
  const { headers } = lazyStep.getHeaders({
    context,
    step: resultStep,
    invokeCount,
    telemetry: telemetry2
  });
  const body = lazyStep.getBody({
    context,
    step: resultStep,
    headers,
    invokeCount,
    telemetry: telemetry2
  });
  const submitResult = await lazyStep.submitStep({
    context,
    body,
    headers,
    isParallel: concurrency !== NO_CONCURRENCY,
    invokeCount,
    step: resultStep,
    telemetry: telemetry2
  });
  if (submitResult && submitResult[0]) {
    await dispatchDebug("onInfo", {
      info: `Submitted step "${resultStep.stepName}" with messageId: ${submitResult[0].messageId}.`
    });
  }
  return resultStep;
};

// src/context/auto-executor.ts
var AutoExecutor = class _AutoExecutor {
  context;
  promises = /* @__PURE__ */ new WeakMap();
  activeLazyStepList;
  nonPlanStepCount;
  steps;
  indexInCurrentList = 0;
  invokeCount;
  telemetry;
  dispatchDebug;
  dispatchLifecycle;
  stepCount = 0;
  planStepCount = 0;
  executingStep = false;
  /**
   * @param context workflow context
   * @param steps list of steps
   * @param dispatchDebug debug event dispatcher
   * @param dispatchLifecycle lifecycle event dispatcher
   * @param telemetry optional telemetry information
   * @param invokeCount optional invoke count
   */
  constructor(context, steps, dispatchDebug, dispatchLifecycle, telemetry2, invokeCount) {
    this.context = context;
    this.steps = steps;
    this.dispatchDebug = dispatchDebug;
    this.dispatchLifecycle = dispatchLifecycle;
    this.telemetry = telemetry2;
    this.invokeCount = invokeCount ?? 0;
    this.nonPlanStepCount = this.steps.filter((step) => !step.targetStep).length;
  }
  /**
   * Adds the step function to the list of step functions to run in
   * parallel. After adding the function, defers the execution, so
   * that if there is another step function to be added, it's also
   * added.
   *
   * After all functions are added, list of functions are executed.
   * If there is a single function, it's executed by itself. If there
   * are multiple, they are run in parallel.
   *
   * If a function is already executing (this.executingStep), this
   * means that there is a nested step which is not allowed. In this
   * case, addStep throws WorkflowError.
   *
   * @param stepInfo step plan to add
   * @returns result of the step function
   */
  async addStep(stepInfo) {
    if (this.executingStep) {
      throw new WorkflowError(
        `A step can not be run inside another step. Tried to run '${stepInfo.stepName}' inside '${this.executingStep}'`
      );
    }
    this.stepCount += 1;
    const lazyStepList = this.activeLazyStepList ?? [];
    if (!this.activeLazyStepList) {
      this.activeLazyStepList = lazyStepList;
      this.indexInCurrentList = 0;
    }
    lazyStepList.push(stepInfo);
    const index = this.indexInCurrentList++;
    const requestComplete = this.deferExecution().then(async () => {
      if (!this.promises.has(lazyStepList)) {
        const promise2 = this.getExecutionPromise(lazyStepList);
        this.promises.set(lazyStepList, promise2);
        this.activeLazyStepList = void 0;
        this.planStepCount += lazyStepList.length > 1 ? lazyStepList.length : 0;
      }
      const promise = this.promises.get(lazyStepList);
      return promise;
    });
    const result = await requestComplete;
    return _AutoExecutor.getResult(lazyStepList, result, index);
  }
  /**
   * Wraps a step function to set this.executingStep to step name
   * before running and set this.executingStep to False after execution
   * ends.
   *
   * this.executingStep allows us to detect nested steps which are not
   * allowed.
   *
   * @param stepName name of the step being wrapped
   * @param stepFunction step function to wrap
   * @returns wrapped step function
   */
  wrapStep(stepName, stepFunction) {
    this.executingStep = stepName;
    const result = stepFunction();
    this.executingStep = false;
    return result;
  }
  /**
   * Executes a step:
   * - If the step result is available in the steps, returns the result
   * - If the result is not available, runs the function
   * - Sends the result to QStash
   *
   * @param lazyStep lazy step to execute
   * @returns step result
   */
  async runSingle(lazyStep) {
    if (this.stepCount < this.nonPlanStepCount) {
      const step = this.steps[this.stepCount + this.planStepCount];
      validateStep(lazyStep, step);
      const parsedOut = lazyStep.parseOut(step);
      const isLastMemoized = this.stepCount + 1 === this.nonPlanStepCount && this.steps.at(-1).stepId !== 0;
      if (isLastMemoized) {
        await this.dispatchLifecycle("afterExecution", {
          stepName: lazyStep.stepName,
          result: parsedOut
        });
      }
      return parsedOut;
    }
    const resultStep = await submitSingleStep({
      context: this.context,
      lazyStep,
      stepId: this.stepCount,
      invokeCount: this.invokeCount,
      concurrency: 1,
      telemetry: this.telemetry,
      dispatchDebug: this.dispatchDebug,
      dispatchLifecycle: this.dispatchLifecycle
    });
    throw new WorkflowAbort(lazyStep.stepName, resultStep);
  }
  /**
   * Runs steps in parallel.
   *
   * @param parallelSteps list of lazy steps to run in parallel
   * @returns results of the functions run in parallel
   */
  async runParallel(parallelSteps) {
    const initialStepCount = this.stepCount - (parallelSteps.length - 1);
    const parallelCallState = this.getParallelCallState(parallelSteps.length, initialStepCount);
    const sortedSteps = sortSteps(this.steps);
    const plannedParallelStepCount = sortedSteps[initialStepCount + this.planStepCount]?.concurrent;
    if (parallelCallState !== "first" && plannedParallelStepCount !== parallelSteps.length) {
      throw new WorkflowError(
        `Incompatible number of parallel steps when call state was '${parallelCallState}'. Expected ${parallelSteps.length}, got ${plannedParallelStepCount} from the request.`
      );
    }
    await this.dispatchDebug("onInfo", {
      info: `Executing parallel steps with: ` + JSON.stringify({
        parallelCallState,
        initialStepCount,
        plannedParallelStepCount,
        stepCount: this.stepCount,
        planStepCount: this.planStepCount
      })
    });
    switch (parallelCallState) {
      case "first": {
        await submitParallelSteps({
          context: this.context,
          steps: parallelSteps,
          initialStepCount,
          invokeCount: this.invokeCount,
          telemetry: this.telemetry,
          dispatchDebug: this.dispatchDebug
        });
        break;
      }
      case "partial": {
        const planStep = this.steps.at(-1);
        if (!planStep || planStep.targetStep === void 0) {
          throw new WorkflowError(
            `There must be a last step and it should have targetStep larger than 0.Received: ${JSON.stringify(planStep)}`
          );
        }
        const stepIndex = planStep.targetStep - initialStepCount;
        validateStep(parallelSteps[stepIndex], planStep);
        try {
          const parallelStep = parallelSteps[stepIndex];
          const resultStep = await submitSingleStep({
            context: this.context,
            lazyStep: parallelStep,
            stepId: planStep.targetStep,
            invokeCount: this.invokeCount,
            concurrency: parallelSteps.length,
            telemetry: this.telemetry,
            dispatchDebug: this.dispatchDebug,
            dispatchLifecycle: this.dispatchLifecycle
          });
          throw new WorkflowAbort(parallelStep.stepName, resultStep);
        } catch (error) {
          if (isInstanceOf(error, WorkflowAbort) || isInstanceOf(error, import_qstash5.QstashError) && error.status === 400) {
            throw error;
          }
          throw new WorkflowError(
            `Error submitting steps to QStash in partial parallel step execution: ${error}`
          );
        }
        break;
      }
      case "discard": {
        const resultStep = this.steps.at(-1);
        const lazyStep = parallelSteps.find(
          (planStep, index) => resultStep.stepId - index === initialStepCount
        );
        if (lazyStep) {
          await this.dispatchLifecycle("afterExecution", {
            stepName: lazyStep.stepName,
            result: lazyStep.parseOut(resultStep)
          });
        }
        throw new WorkflowAbort("discarded parallel");
      }
      case "last": {
        const parallelResultSteps = sortedSteps.filter((step) => step.stepId >= initialStepCount).slice(0, parallelSteps.length);
        validateParallelSteps(parallelSteps, parallelResultSteps);
        const isLastMemoized = this.stepCount + 1 === this.nonPlanStepCount && this.steps.at(-1).stepId !== 0;
        if (isLastMemoized) {
          const resultStep = this.steps.at(-1);
          const lazyStep = parallelSteps.find(
            (planStep, index) => resultStep.stepId - index === initialStepCount
          );
          await this.dispatchLifecycle("afterExecution", {
            stepName: lazyStep.stepName,
            result: lazyStep.parseOut(resultStep)
          });
        }
        return parallelResultSteps.map(
          (step, index) => parallelSteps[index].parseOut(step)
        );
      }
    }
    const fillValue = void 0;
    return Array.from({ length: parallelSteps.length }).fill(fillValue);
  }
  /**
   * Determines the parallel call state
   *
   * First filters the steps to get the steps which are after `initialStepCount` parameter.
   *
   * Depending on the remaining steps, decides the parallel state:
   * - "first": If there are no steps
   * - "last" If there are equal to or more than `2 * parallelStepCount`. We multiply by two
   *   because each step in a parallel execution will have 2 steps: a plan step and a result
   *   step.
   * - "partial": If the last step is a plan step
   * - "discard": If the last step is not a plan step. This means that the parallel execution
   *   is in progress (there are still steps to run) and one step has finished and submitted
   *   its result to QStash
   *
   * @param parallelStepCount number of steps to run in parallel
   * @param initialStepCount steps after the parallel invocation
   * @returns parallel call state
   */
  getParallelCallState(parallelStepCount, initialStepCount) {
    const remainingSteps = this.steps.filter(
      (step) => (step.targetStep || step.stepId) >= initialStepCount
    );
    if (remainingSteps.length === 0) {
      return "first";
    } else if (remainingSteps.length >= 2 * parallelStepCount) {
      return "last";
    } else if (remainingSteps.at(-1)?.targetStep) {
      return "partial";
    } else {
      return "discard";
    }
  }
  /**
   * Get the promise by executing the lazt steps list. If there is a single
   * step, we call `runSingle`. Otherwise `runParallel` is called.
   *
   * @param lazyStepList steps list to execute
   * @returns promise corresponding to the execution
   */
  getExecutionPromise(lazyStepList) {
    return lazyStepList.length === 1 ? this.runSingle(lazyStepList[0]) : this.runParallel(lazyStepList);
  }
  /**
   * @param lazyStepList steps we executed
   * @param result result of the promise from `getExecutionPromise`
   * @param index index of the current step
   * @returns result[index] if lazyStepList > 1, otherwise result
   */
  static getResult(lazyStepList, result, index) {
    if (lazyStepList.length === 1) {
      return result;
    } else if (Array.isArray(result) && lazyStepList.length === result.length && index < lazyStepList.length) {
      return result[index];
    } else {
      throw new WorkflowError(
        `Unexpected parallel call result while executing step ${index}: '${result}'. Expected ${lazyStepList.length} many items`
      );
    }
  }
  async deferExecution() {
    await Promise.resolve();
    await Promise.resolve();
  }
};
var validateStep = (lazyStep, stepFromRequest) => {
  if (lazyStep.stepName !== stepFromRequest.stepName) {
    throw new WorkflowError(
      `Incompatible step name. Expected '${lazyStep.stepName}', got '${stepFromRequest.stepName}' from the request`
    );
  }
  if (lazyStep.stepType !== stepFromRequest.stepType) {
    throw new WorkflowError(
      `Incompatible step type. Expected '${lazyStep.stepType}', got '${stepFromRequest.stepType}' from the request`
    );
  }
};
var validateParallelSteps = (lazySteps, stepsFromRequest) => {
  try {
    for (const [index, stepFromRequest] of stepsFromRequest.entries()) {
      validateStep(lazySteps[index], stepFromRequest);
    }
  } catch (error) {
    if (isInstanceOf(error, WorkflowError)) {
      const lazyStepNames = lazySteps.map((lazyStep) => lazyStep.stepName);
      const lazyStepTypes = lazySteps.map((lazyStep) => lazyStep.stepType);
      const requestStepNames = stepsFromRequest.map((step) => step.stepName);
      const requestStepTypes = stepsFromRequest.map((step) => step.stepType);
      throw new WorkflowError(
        `Incompatible steps detected in parallel execution: ${error.message}
  > Step Names from the request: ${JSON.stringify(requestStepNames)}
    Step Types from the request: ${JSON.stringify(requestStepTypes)}
  > Step Names expected: ${JSON.stringify(lazyStepNames)}
    Step Types expected: ${JSON.stringify(lazyStepTypes)}`
      );
    }
    throw error;
  }
};
var sortSteps = (steps) => {
  const getStepId = (step) => step.targetStep || step.stepId;
  return [...steps].sort((step, stepOther) => getStepId(step) - getStepId(stepOther));
};

// src/context/api/anthropic.ts
var import_qstash6 = require("@upstash/qstash");

// src/context/provider.ts
var getProviderInfo = (api) => {
  if (!api.provider) {
    throw new WorkflowError("A Provider must be provided.");
  }
  if (api.provider.owner === "upstash") {
    throw new WorkflowError("Upstash provider isn't supported.");
  }
  const { name, provider, ...parameters } = api;
  if (!provider.baseUrl) throw new TypeError("baseUrl cannot be empty or undefined!");
  if (!provider.token) throw new TypeError("token cannot be empty or undefined!");
  if (provider.apiKind !== name) {
    throw new TypeError(`Unexpected api name. Expected '${provider.apiKind}', received ${name}`);
  }
  const providerInfo = {
    url: provider.getUrl(),
    baseUrl: provider.baseUrl,
    route: provider.getRoute(),
    appendHeaders: provider.getHeaders(parameters),
    owner: provider.owner,
    method: provider.method
  };
  return provider.onFinish(providerInfo, parameters);
};

// src/context/api/base.ts
var BaseWorkflowApi = class {
  context;
  /**
   * @param context workflow context
   */
  constructor({ context }) {
    this.context = context;
  }
  /**
   * context.call which uses a QStash API
   *
   * @param stepName name of the step
   * @param settings call settings including api configuration
   * @returns call response
   */
  async callApi(stepName, settings) {
    const { url, appendHeaders, method } = getProviderInfo(settings.api);
    const { method: userMethod, body, headers = {}, retries = 0, retryDelay, timeout } = settings;
    return await this.context.call(stepName, {
      url,
      method: userMethod ?? method,
      body: typeof body === "string" ? body : JSON.stringify(body),
      headers: {
        ...appendHeaders,
        ...headers
      },
      retries,
      retryDelay,
      timeout
    });
  }
};

// src/context/api/anthropic.ts
var AnthropicAPI = class extends BaseWorkflowApi {
  async call(stepName, settings) {
    const { token, operation, ...parameters } = settings;
    return await this.callApi(stepName, {
      api: {
        name: "llm",
        provider: (0, import_qstash6.anthropic)({ token })
      },
      ...parameters
    });
  }
};

// src/context/api/openai.ts
var import_qstash7 = require("@upstash/qstash");
var OpenAIAPI = class extends BaseWorkflowApi {
  async call(stepName, settings) {
    const { token, organization, operation, baseURL, ...parameters } = settings;
    const useOpenAI = baseURL === void 0;
    const provider = useOpenAI ? (0, import_qstash7.openai)({ token, organization }) : (0, import_qstash7.custom)({ baseUrl: baseURL, token });
    return await this.callApi(stepName, {
      api: {
        name: "llm",
        provider
      },
      ...parameters
    });
  }
};

// src/context/api/resend.ts
var import_qstash8 = require("@upstash/qstash");
var ResendAPI = class extends BaseWorkflowApi {
  async call(stepName, settings) {
    const { token, batch = false, ...parameters } = settings;
    return await this.callApi(stepName, {
      api: {
        name: "email",
        provider: (0, import_qstash8.resend)({ token, batch })
      },
      ...parameters
    });
  }
};

// src/context/api/index.ts
var WorkflowApi = class extends BaseWorkflowApi {
  get openai() {
    return new OpenAIAPI({
      context: this.context
    });
  }
  get resend() {
    return new ResendAPI({
      context: this.context
    });
  }
  get anthropic() {
    return new AnthropicAPI({
      context: this.context
    });
  }
};

// src/serve/serve-many.ts
var getWorkflowId = (url) => {
  const components = url.split("/");
  const lastComponent = components[components.length - 1];
  return lastComponent.split("?")[0];
};
var serveManyBase = ({
  workflows,
  getUrl,
  serveMethod,
  options
}) => {
  const workflowIds = [];
  const workflowMap = Object.fromEntries(
    Object.entries(workflows).map((workflow) => {
      const workflowId = workflow[0];
      if (workflowIds.includes(workflowId)) {
        throw new WorkflowError(
          `Duplicate workflow name found: '${workflowId}'. Please set different workflow names in serveMany.`
        );
      }
      if (workflowId.includes("/")) {
        throw new WorkflowError(
          `Invalid workflow name found: '${workflowId}'. Workflow name cannot contain '/'.`
        );
      }
      workflowIds.push(workflowId);
      workflow[1].workflowId = workflowId;
      workflow[1].options = {
        ...options,
        ...workflow[1].options
      };
      const params = [workflow[1].routeFunction, workflow[1].options];
      const handler = serveMethod(...params);
      return [workflowId, handler];
    })
  );
  return {
    handler: async (...params) => {
      const url = getUrl(...params);
      const pickedWorkflowId = getWorkflowId(url);
      if (!pickedWorkflowId) {
        return new Response(
          `Unexpected request in serveMany. workflowId not set. Please update the URL of your request.`,
          {
            status: 404,
            headers: {
              [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
            }
          }
        );
      }
      const workflow = workflowMap[pickedWorkflowId];
      if (!workflow) {
        return new Response(
          `No workflows in serveMany found for '${pickedWorkflowId}'. Please update the URL of your request.`,
          {
            status: 404,
            headers: {
              [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
            }
          }
        );
      }
      return await workflow(...params);
    }
  };
};
var getNewUrlFromWorkflowId = (url, workflowId) => {
  if (!workflowId) {
    throw new WorkflowError("You can only call workflow which has a workflowId");
  }
  return url.replace(/[^/]+$/, workflowId);
};

// src/middleware/default-callbacks.ts
var onErrorWithConsole = async ({ workflowRunId, error }) => {
  console.error(`  [Upstash Workflow]: Error in workflow run ${workflowRunId}: ` + error);
};
var onWarningWithConsole = async ({ workflowRunId, warning }) => {
  console.warn(`  [Upstash Workflow]: Warning in workflow run ${workflowRunId}: ` + warning);
};
var onInfoWithConsole = async ({
  workflowRunId,
  info
}) => {
  console.info(`  [Upstash Workflow]: Info in workflow run ${workflowRunId}: ` + info);
};

// src/middleware/manager.ts
var MiddlewareManager = class {
  middlewares;
  workflowRunId;
  context;
  /**
   * @param middlewares list of workflow middlewares
   */
  constructor(middlewares = []) {
    this.middlewares = middlewares;
  }
  /**
   * Assign workflow run ID - will be passed to debug events
   *
   * @param workflowRunId workflow run id to assign
   */
  assignWorkflowRunId(workflowRunId) {
    this.workflowRunId = workflowRunId;
  }
  /**
   * Assign context - required for lifecycle events
   *
   * also assigns workflowRunId from context
   *
   * @param context workflow context to assign
   */
  assignContext(context) {
    this.context = context;
    this.workflowRunId = context.workflowRunId;
  }
  /**
   * Internal method to execute middlewares with common error handling logic
   *
   * @param event event name to dispatch
   * @param params event parameters
   */
  async executeMiddlewares(event, params) {
    await Promise.all(this.middlewares.map((m) => m.ensureInit()));
    await Promise.all(
      this.middlewares.map(async (middleware) => {
        const callback = middleware.getCallback(event);
        if (callback) {
          try {
            await callback(params);
          } catch (error) {
            try {
              const onErrorCallback = middleware.getCallback("onError") ?? onErrorWithConsole;
              await onErrorCallback({
                workflowRunId: this.workflowRunId,
                error
              });
            } catch (onErrorError) {
              console.error(
                `Failed while executing "onError" of middleware "${middleware.name}", falling back to logging the error to console. Error: ${onErrorError}`
              );
              onErrorWithConsole({
                workflowRunId: this.workflowRunId,
                error
              });
            }
          }
        }
      })
    );
    if (event === "onError") {
      onErrorWithConsole({
        workflowRunId: this.workflowRunId,
        ...params
      });
    } else if (event === "onWarning") {
      onWarningWithConsole({
        workflowRunId: this.workflowRunId,
        ...params
      });
    }
  }
  /**
   * Dispatch a debug event (onError, onWarning, onInfo)
   *
   * @param event debug event name
   * @param params event parameters
   */
  async dispatchDebug(event, params) {
    const paramsWithRunId = {
      ...params,
      workflowRunId: this.workflowRunId
    };
    await this.executeMiddlewares(event, paramsWithRunId);
  }
  /**
   * Dispatch a lifecycle event (beforeExecution, afterExecution, runStarted, runCompleted)
   *
   * @param event lifecycle event name
   * @param params event parameters
   */
  async dispatchLifecycle(event, params) {
    if (!this.context) {
      throw new WorkflowError(
        `Something went wrong while calling middlewares. Lifecycle event "${event}" was called before assignContext.`
      );
    }
    const paramsWithContext = {
      ...params,
      context: this.context
    };
    await this.executeMiddlewares(event, paramsWithContext);
  }
};

// src/context/context.ts
var WorkflowContext = class {
  executor;
  steps;
  /**
   * QStash client of the workflow
   *
   * Can be overwritten by passing `qstashClient` parameter in `serve`:
   *
   * ```ts
   * import { Client } from "@upstash/qstash"
   *
   * export const POST = serve(
   *   async (context) => {
   *     ...
   *   },
   *   {
   *     qstashClient: new Client({...})
   *   }
   * )
   * ```
   */
  qstashClient;
  /**
   * Run id of the workflow
   */
  workflowRunId;
  /**
   * Creation time of the workflow run
   */
  workflowRunCreatedAt;
  /**
   * URL of the workflow
   *
   * Can be overwritten by passing a `url` parameter in `serve`:
   *
   * ```ts
   * export const POST = serve(
   *   async (context) => {
   *     ...
   *   },
   *   {
   *     url: "new-url-value"
   *   }
   * )
   * ```
   */
  url;
  /**
   * Payload of the request which started the workflow.
   *
   * To specify its type, you can define `serve` as follows:
   *
   * ```ts
   * // set requestPayload type to MyPayload:
   * export const POST = serve<MyPayload>(
   *   async (context) => {
   *     ...
   *   }
   * )
   * ```
   *
   * By default, `serve` tries to apply `JSON.parse` to the request payload.
   * If your payload is encoded in a format other than JSON, you can utilize
   * the `initialPayloadParser` parameter:
   *
   * ```ts
   * export const POST = serve<MyPayload>(
   *   async (context) => {
   *     ...
   *   },
   *   {
   *     initialPayloadParser: (initialPayload) => {return doSomething(initialPayload)}
   *   }
   * )
   * ```
   */
  requestPayload;
  /**
   * headers of the initial request
   */
  headers;
  /**
   * Map of environment variables and their values.
   *
   * Can be set using the `env` option of serve:
   *
   * ```ts
   * export const POST = serve<MyPayload>(
   *   async (context) => {
   *     const key = context.env["API_KEY"];
   *   },
   *   {
   *     env: {
   *       "API_KEY": "*****";
   *     }
   *   }
   * )
   * ```
   *
   * Default value is set to `process.env`.
   */
  env;
  /**
   * Label to apply to the workflow run.
   *
   * Can be used to filter the workflow run logs.
   *
   * Can be set by passing a `label` parameter when triggering the workflow
   * with `client.trigger`:
   *
   * ```ts
   * await client.trigger({
   *   url: "https://workflow-endpoint.com",
   *   label: "my-label"
   * });
   * ```
   */
  label;
  constructor({
    qstashClient,
    workflowRunId,
    workflowRunCreatedAt,
    headers,
    steps,
    url,
    initialPayload,
    env,
    telemetry: telemetry2,
    invokeCount,
    label,
    middlewareManager
  }) {
    this.qstashClient = qstashClient;
    this.workflowRunId = workflowRunId;
    this.workflowRunCreatedAt = workflowRunCreatedAt;
    this.steps = steps;
    this.url = url;
    this.headers = headers;
    this.requestPayload = initialPayload;
    this.env = env ?? {};
    this.label = label;
    const middlewareManagerInstance = middlewareManager ?? new MiddlewareManager([]);
    middlewareManagerInstance.assignContext(this);
    this.executor = new AutoExecutor(
      this,
      this.steps,
      middlewareManagerInstance.dispatchDebug.bind(middlewareManagerInstance),
      middlewareManagerInstance.dispatchLifecycle.bind(middlewareManagerInstance),
      telemetry2,
      invokeCount
    );
  }
  /**
   * Executes a workflow step
   *
   * ```typescript
   * const result = await context.run("step 1", () => {
   *   return "result"
   * })
   * ```
   *
   * Can also be called in parallel and the steps will be executed
   * simulatenously:
   *
   * ```typescript
   * const [result1, result2] = await Promise.all([
   *   context.run("step 1", () => {
   *     return "result1"
   *   }),
   *   context.run("step 2", async () => {
   *     return await fetchResults()
   *   })
   * ])
   * ```
   *
   * @param stepName name of the step
   * @param stepFunction step function to be executed
   * @returns result of the step function
   */
  async run(stepName, stepFunction) {
    const wrappedStepFunction = (() => this.executor.wrapStep(stepName, stepFunction));
    return await this.addStep(new LazyFunctionStep(this, stepName, wrappedStepFunction));
  }
  /**
   * Stops the execution for the duration provided.
   *
   * ```typescript
   * await context.sleep('sleep1', 3) // wait for three seconds
   * ```
   *
   * @param stepName
   * @param duration sleep duration in seconds
   * @returns undefined
   */
  async sleep(stepName, duration) {
    await this.addStep(new LazySleepStep(this, stepName, duration));
  }
  /**
   * Stops the execution until the date time provided.
   *
   * ```typescript
   * await context.sleepUntil('sleep1', Date.now() / 1000 + 3) // wait for three seconds
   * ```
   *
   * @param stepName
   * @param datetime time to sleep until. Can be provided as a number (in unix seconds),
   *   as a Date object or a string (passed to `new Date(datetimeString)`)
   * @returns undefined
   */
  async sleepUntil(stepName, datetime) {
    let time;
    if (typeof datetime === "number") {
      time = datetime;
    } else {
      datetime = typeof datetime === "string" ? new Date(datetime) : datetime;
      time = Math.round(datetime.getTime() / 1e3);
    }
    await this.addStep(new LazySleepUntilStep(this, stepName, time));
  }
  async call(stepName, settings) {
    let callStep;
    if ("workflow" in settings) {
      const url = getNewUrlFromWorkflowId(this.url, settings.workflow.workflowId);
      const stringBody = typeof settings.body === "string" ? settings.body : settings.body === void 0 ? void 0 : JSON.stringify(settings.body);
      callStep = new LazyCallStep({
        context: this,
        stepName,
        url,
        method: "POST",
        body: stringBody,
        headers: settings.headers || {},
        retries: settings.retries || 0,
        retryDelay: settings.retryDelay,
        timeout: settings.timeout,
        flowControl: settings.flowControl
      });
    } else {
      callStep = new LazyCallStep({
        context: this,
        stepName,
        url: settings.url,
        method: settings.method ?? "GET",
        body: settings.body,
        headers: settings.headers ?? {},
        retries: settings.retries ?? 0,
        retryDelay: settings.retryDelay,
        timeout: settings.timeout,
        flowControl: settings.flowControl
      });
    }
    return await this.addStep(callStep);
  }
  /**
   * Pauses workflow execution until a specific event occurs or a timeout is reached.
   *
   *```ts
   * const result = await workflow.waitForEvent("payment-confirmed", "payment.confirmed", {
   *   timeout: "5m"
   * });
   *```
   *
   * To notify a waiting workflow:
   *
   * ```ts
   * import { Client } from "@upstash/workflow";
   *
   * const client = new Client({ token: "<QSTASH_TOKEN>" });
   *
   * await client.notify({
   *   eventId: "payment.confirmed",
   *   data: {
   *     amount: 99.99,
   *     currency: "USD"
   *   }
   * })
   * ```
   *
   * Alternatively, you can use the `context.notify` method.
   *
   * @param stepName
   * @param eventId - Unique identifier for the event to wait for
   * @param options - Configuration options.
   * @returns `{ timeout: boolean, eventData: TEventData }`.
   *   The `timeout` property specifies if the workflow has timed out. The `eventData`
   *   is the data passed when notifying this workflow of an event.
   */
  async waitForEvent(stepName, eventId, options = {}) {
    const { timeout = "7d" } = options;
    const timeoutStr = typeof timeout === "string" ? timeout : `${timeout}s`;
    return await this.addStep(
      new LazyWaitForEventStep(this, stepName, eventId, timeoutStr)
    );
  }
  /**
   * Notify workflow runs waiting for an event
   *
   * ```ts
   * const { eventId, eventData, notifyResponse } = await context.notify(
   *   "notify step", "event-id", "event-data"
   * );
   * ```
   *
   * Upon `context.notify`, the workflow runs waiting for the given eventId (context.waitForEvent)
   * will receive the given event data and resume execution.
   *
   * The response includes the same eventId and eventData. Additionally, there is
   * a notifyResponse field which contains a list of `Waiter` objects, each corresponding
   * to a notified workflow run.
   *
   * @param stepName
   * @param eventId event id to notify
   * @param eventData event data to notify with
   * @returns notify response which has event id, event data and list of waiters which were notified
   */
  async notify(stepName, eventId, eventData) {
    return await this.addStep(
      new LazyNotifyStep(this, stepName, eventId, eventData, this.qstashClient.http)
    );
  }
  async invoke(stepName, settings) {
    return await this.addStep(
      new LazyInvokeStep(this, stepName, settings)
    );
  }
  async createWebhook(stepName) {
    return await this.addStep(new LazyCreateWebhookStep(this, stepName));
  }
  async waitForWebhook(stepName, webhook, timeout) {
    return await this.addStep(new LazyWaitForWebhookStep(this, stepName, webhook, timeout));
  }
  /**
   * Cancel the current workflow run
   *
   * Will throw WorkflowCancelAbort to stop workflow execution.
   * Shouldn't be inside try/catch.
   */
  async cancel() {
    throw new WorkflowCancelAbort();
  }
  /**
   * Adds steps to the executor. Needed so that it can be overwritten in
   * DisabledWorkflowContext.
   */
  async addStep(step) {
    return await this.executor.addStep(step);
  }
  get api() {
    return new WorkflowApi({
      context: this
    });
  }
};

// src/serve/authorization.ts
var import_qstash9 = require("@upstash/qstash");
var DisabledWorkflowContext = class _DisabledWorkflowContext extends WorkflowContext {
  static disabledMessage = "disabled-qstash-worklfow-run";
  disabled = true;
  /**
   * overwrite the WorkflowContext.addStep method to always raise WorkflowAuthError
   * error in order to stop the execution whenever we encounter a step.
   *
   * @param _step
   */
  async addStep(_step) {
    throw new WorkflowAuthError(_DisabledWorkflowContext.disabledMessage);
  }
  /**
   * overwrite cancel method to throw WorkflowAuthError with the disabledMessage
   */
  async cancel() {
    throw new WorkflowAuthError(_DisabledWorkflowContext.disabledMessage);
  }
  /**
   * copies the passed context to create a DisabledWorkflowContext. Then, runs the
   * route function with the new context.
   *
   * - returns "run-ended" if there are no steps found or
   *      if the auth failed and user called `return`
   * - returns "step-found" if DisabledWorkflowContext.addStep is called.
   * - if there is another error, returns the error.
   *
   * @param routeFunction
   */
  static async tryAuthentication(routeFunction, context) {
    const disabledContext = new _DisabledWorkflowContext({
      qstashClient: new import_qstash9.Client({
        baseUrl: "disabled-client",
        token: "disabled-client"
      }),
      workflowRunId: context.workflowRunId,
      workflowRunCreatedAt: context.workflowRunCreatedAt,
      headers: context.headers,
      steps: [],
      url: context.url,
      initialPayload: context.requestPayload,
      env: context.env,
      label: context.label
    });
    try {
      await routeFunction(disabledContext);
    } catch (error) {
      if (isInstanceOf(error, WorkflowAuthError) && error.stepName === this.disabledMessage || isInstanceOf(error, WorkflowNonRetryableError) || isInstanceOf(error, WorkflowRetryAfterError)) {
        return ok("step-found");
      }
      console.warn(
        "Upstash Workflow: Received an error while authorizing request. Please avoid throwing errors before the first step of your workflow."
      );
      return err(error);
    }
    return ok("run-ended");
  }
};

// src/workflow-parser.ts
var getPayload = async (request) => {
  try {
    return await request.text();
  } catch {
    return;
  }
};
var processRawSteps = (rawSteps) => {
  const [encodedInitialPayload, ...encodedSteps] = rawSteps;
  const rawInitialPayload = decodeBase64(encodedInitialPayload.body);
  const initialStep = {
    stepId: 0,
    stepName: "init",
    stepType: "Initial",
    out: rawInitialPayload,
    concurrent: NO_CONCURRENCY
  };
  const stepsToDecode = encodedSteps.filter((step) => step.callType === "step");
  const otherSteps = stepsToDecode.map((rawStep) => {
    const step = JSON.parse(decodeBase64(rawStep.body));
    return step;
  });
  const steps = [initialStep, ...otherSteps];
  return {
    rawInitialPayload,
    steps
  };
};
var deduplicateSteps = (steps) => {
  const targetStepIds = [];
  const stepIds = [];
  const deduplicatedSteps = [];
  for (const step of steps) {
    if (step.stepId === 0) {
      if (!targetStepIds.includes(step.targetStep ?? 0)) {
        deduplicatedSteps.push(step);
        targetStepIds.push(step.targetStep ?? 0);
      }
    } else {
      if (!stepIds.includes(step.stepId)) {
        deduplicatedSteps.push(step);
        stepIds.push(step.stepId);
      }
    }
  }
  return deduplicatedSteps;
};
var checkIfLastOneIsDuplicate = async (steps, dispatchDebug) => {
  if (steps.length < 2) {
    return false;
  }
  const lastStep = steps.at(-1);
  const lastStepId = lastStep.stepId;
  const lastTargetStepId = lastStep.targetStep;
  for (let index = 0; index < steps.length - 1; index++) {
    const step = steps[index];
    if (step.stepId === lastStepId && step.targetStep === lastTargetStepId) {
      const message = `Upstash Workflow: The step '${step.stepName}' with id '${step.stepId}'  has run twice during workflow execution. Rest of the workflow will continue running as usual.`;
      await dispatchDebug?.("onWarning", {
        warning: message
      });
      return true;
    }
  }
  return false;
};
var validateRequest = (request) => {
  if (request.headers.get(WORKFLOW_UNKOWN_SDK_VERSION_HEADER)) {
    const workflowRunId2 = request.headers.get(WORKFLOW_ID_HEADER);
    if (!workflowRunId2) {
      throw new WorkflowError(
        "Couldn't get workflow id from header when handling unknown sdk request"
      );
    }
    return {
      unknownSdk: true,
      isFirstInvocation: true,
      workflowRunId: workflowRunId2
    };
  }
  if (request.headers.get(WORKFLOW_FAILURE_CALLBACK_HEADER)) {
    const workflowRunId2 = request.headers.get(WORKFLOW_ID_HEADER);
    if (!workflowRunId2) {
      throw new WorkflowError(
        "Couldn't get workflow id from header when handling failure callback request"
      );
    }
    return {
      unknownSdk: false,
      isFirstInvocation: true,
      workflowRunId: workflowRunId2
    };
  }
  const versionHeader = request.headers.get(WORKFLOW_PROTOCOL_VERSION_HEADER);
  const isFirstInvocation = !versionHeader;
  if (!isFirstInvocation && versionHeader !== WORKFLOW_PROTOCOL_VERSION) {
    throw new WorkflowError(
      `Incompatible workflow sdk protocol version. Expected ${WORKFLOW_PROTOCOL_VERSION}, got ${versionHeader} from the request.`
    );
  }
  const workflowRunId = isFirstInvocation ? getWorkflowRunId() : request.headers.get(WORKFLOW_ID_HEADER) ?? "";
  if (workflowRunId.length === 0) {
    throw new WorkflowError("Couldn't get workflow id from header");
  }
  return {
    isFirstInvocation,
    workflowRunId,
    unknownSdk: false
  };
};
var parseRequest = async ({
  requestPayload,
  isFirstInvocation,
  unknownSdk,
  workflowRunId,
  requester,
  messageId,
  dispatchDebug
}) => {
  if (isFirstInvocation && !unknownSdk) {
    return {
      rawInitialPayload: requestPayload ?? "",
      steps: [],
      isLastDuplicate: false,
      workflowRunEnded: false
    };
  } else {
    let rawSteps;
    if (!requestPayload) {
      await dispatchDebug?.("onInfo", {
        info: "request payload is empty, steps will be fetched from QStash."
      });
      const { steps: fetchedSteps, workflowRunEnded } = await getSteps(
        requester,
        workflowRunId,
        messageId,
        dispatchDebug
      );
      if (workflowRunEnded) {
        return {
          rawInitialPayload: void 0,
          steps: void 0,
          isLastDuplicate: void 0,
          workflowRunEnded: true
        };
      }
      rawSteps = fetchedSteps;
    } else {
      rawSteps = JSON.parse(requestPayload);
    }
    const { rawInitialPayload, steps } = processRawSteps(rawSteps);
    const isLastDuplicate = await checkIfLastOneIsDuplicate(steps, dispatchDebug);
    const deduplicatedSteps = deduplicateSteps(steps);
    return {
      rawInitialPayload,
      steps: deduplicatedSteps,
      isLastDuplicate,
      workflowRunEnded: false
    };
  }
};
var handleFailure = async ({
  request,
  requestPayload,
  qstashClient,
  initialPayloadParser,
  routeFunction,
  failureFunction,
  env,
  dispatchDebug
}) => {
  if (request.headers.get(WORKFLOW_FAILURE_HEADER) !== "true" && !request.headers.get(WORKFLOW_FAILURE_CALLBACK_HEADER)) {
    return ok({ result: "not-failure-callback" });
  }
  if (!failureFunction) {
    return ok({ result: "failure-function-undefined" });
  }
  try {
    const { status, header, body, url, sourceBody, workflowRunId, workflowCreatedAt } = JSON.parse(
      requestPayload
    );
    const decodedBody = body ? decodeBase64(body) : "{}";
    let errorMessage = "";
    let failStack = "";
    try {
      const errorPayload = JSON.parse(decodedBody);
      if (errorPayload.message) {
        errorMessage = errorPayload.message;
      }
      if (errorPayload.stack) {
        failStack = errorPayload.stack;
      }
    } catch {
    }
    if (!errorMessage) {
      errorMessage = `Couldn't parse 'failResponse' in 'failureFunction', received: '${decodedBody}'`;
    }
    const userHeaders = recreateUserHeaders(request.headers);
    const workflowContext = new WorkflowContext({
      qstashClient,
      workflowRunId,
      initialPayload: sourceBody ? initialPayloadParser(decodeBase64(sourceBody)) : void 0,
      headers: userHeaders,
      steps: [],
      url,
      env,
      telemetry: void 0,
      // not going to make requests in authentication check
      label: userHeaders.get(WORKFLOW_LABEL_HEADER) ?? void 0,
      workflowRunCreatedAt: workflowCreatedAt,
      middlewareManager: void 0
    });
    const authCheck = await DisabledWorkflowContext.tryAuthentication(
      routeFunction,
      workflowContext
    );
    if (authCheck.isErr()) {
      await dispatchDebug?.("onError", {
        error: authCheck.error
      });
      return err(authCheck.error);
    } else if (authCheck.value === "run-ended") {
      return err(new WorkflowError("Not authorized to run the failure function."));
    }
    const failureResponse = await failureFunction({
      context: workflowContext,
      failStatus: status,
      failResponse: errorMessage,
      failHeaders: header,
      failStack
    });
    return ok({ result: "failure-function-executed", response: failureResponse });
  } catch (error) {
    return err(error);
  }
};

// src/serve/multi-region/handlers.ts
var import_qstash10 = require("@upstash/qstash");

// src/serve/multi-region/utils.ts
var VALID_REGIONS = ["EU_CENTRAL_1", "US_EAST_1"];
var getRegionFromEnvironment = (environment) => {
  const region = environment.QSTASH_REGION;
  return normalizeRegionHeader(region);
};
function readEnvironmentVariables(environmentVariables, environment, region) {
  const result = {};
  for (const variable of environmentVariables) {
    const key = region ? `${region}_${variable}` : variable;
    result[variable] = environment[key];
  }
  return result;
}
function readClientEnvironmentVariables(environment, region) {
  return readEnvironmentVariables(["QSTASH_URL", "QSTASH_TOKEN"], environment, region);
}
function readReceiverEnvironmentVariables(environment, region) {
  return readEnvironmentVariables(
    ["QSTASH_CURRENT_SIGNING_KEY", "QSTASH_NEXT_SIGNING_KEY"],
    environment,
    region
  );
}
function normalizeRegionHeader(region) {
  if (!region) {
    return void 0;
  }
  region = region.replaceAll("-", "_").toUpperCase();
  if (VALID_REGIONS.includes(region)) {
    return region;
  }
  console.warn(
    `[Upstash Workflow] Invalid UPSTASH-REGION header value: "${region}". Expected one of: ${VALID_REGIONS.join(
      ", "
    )}.`
  );
  return void 0;
}

// src/serve/multi-region/handlers.ts
var getHandlersForRequest = (qstashHandlers, regionHeader, isFirstInvocation) => {
  if (qstashHandlers.mode === "single-region") {
    return qstashHandlers.handlers;
  }
  let targetRegion;
  if (isFirstInvocation && !regionHeader) {
    targetRegion = qstashHandlers.defaultRegion;
  } else {
    const normalizedRegion = regionHeader ? normalizeRegionHeader(regionHeader) : void 0;
    targetRegion = normalizedRegion ?? qstashHandlers.defaultRegion;
  }
  const handler = qstashHandlers.handlers[targetRegion];
  if (!handler) {
    console.warn(
      `[Upstash Workflow] No handler found for region "${targetRegion}". Falling back to default region.`
    );
    return qstashHandlers.handlers[qstashHandlers.defaultRegion];
  }
  return handler;
};
var createRegionalHandler = (environment, receiverConfig, region, clientOptions) => {
  const clientEnv = readClientEnvironmentVariables(environment, region);
  const client = new import_qstash10.Client({
    ...clientOptions,
    baseUrl: clientEnv.QSTASH_URL,
    token: clientEnv.QSTASH_TOKEN
  });
  const receiver = getReceiver(environment, receiverConfig, region);
  return { client, receiver };
};
var shouldUseMultiRegionMode = (environment, qstashClientOption) => {
  const hasRegionEnv = Boolean(getRegionFromEnvironment(environment));
  if (hasRegionEnv && (!qstashClientOption || !("http" in qstashClientOption))) {
    return {
      isMultiRegion: true,
      defaultRegion: getRegionFromEnvironment(environment),
      clientOptions: qstashClientOption
    };
  } else {
    return { isMultiRegion: false };
  }
};
var getQStashHandlers = ({
  environment,
  qstashClientOption,
  receiverConfig
}) => {
  const multiRegion = shouldUseMultiRegionMode(environment, qstashClientOption);
  if (multiRegion.isMultiRegion) {
    const regions = ["US_EAST_1", "EU_CENTRAL_1"];
    const handlers = {};
    for (const region of regions) {
      try {
        handlers[region] = createRegionalHandler(
          environment,
          receiverConfig,
          region,
          multiRegion.clientOptions
        );
      } catch (error) {
        console.warn(`[Upstash Workflow] Failed to create handler for region ${region}:`, error);
      }
    }
    return {
      mode: "multi-region",
      handlers,
      defaultRegion: multiRegion.defaultRegion
    };
  } else {
    return {
      mode: "single-region",
      handlers: {
        client: qstashClientOption && "http" in qstashClientOption ? qstashClientOption : new import_qstash10.Client({
          ...qstashClientOption,
          baseUrl: environment.QSTASH_URL,
          token: environment.QSTASH_TOKEN
        }),
        receiver: getReceiver(environment, receiverConfig)
      }
    };
  }
};
var getReceiver = (environment, receiverConfig, region) => {
  if (typeof receiverConfig === "string") {
    if (receiverConfig === "set-to-undefined") {
      return void 0;
    }
    const receiverEnv = readReceiverEnvironmentVariables(environment, region);
    return receiverEnv.QSTASH_CURRENT_SIGNING_KEY && receiverEnv.QSTASH_NEXT_SIGNING_KEY ? new import_qstash10.Receiver({
      currentSigningKey: receiverEnv.QSTASH_CURRENT_SIGNING_KEY,
      nextSigningKey: receiverEnv.QSTASH_NEXT_SIGNING_KEY
    }) : void 0;
  } else {
    return receiverConfig;
  }
};
var getQStashHandlerOptions = (...params) => {
  const handlers = getQStashHandlers(...params);
  return {
    qstashHandlers: handlers,
    defaultReceiver: handlers.mode === "single-region" ? handlers.handlers.receiver : handlers.handlers[handlers.defaultRegion].receiver,
    defaultClient: handlers.mode === "single-region" ? handlers.handlers.client : handlers.handlers[handlers.defaultRegion].client
  };
};

// src/middleware/middleware.ts
var WorkflowMiddleware = class {
  name;
  initCallbacks;
  /**
   * Callback functions
   *
   * Initially set to undefined, will be populated after init is called
   */
  middlewareCallbacks = void 0;
  constructor(parameters) {
    this.name = parameters.name;
    if ("init" in parameters) {
      this.initCallbacks = parameters.init;
    } else {
      this.middlewareCallbacks = parameters.callbacks;
    }
  }
  async ensureInit() {
    if (!this.middlewareCallbacks) {
      if (!this.initCallbacks) {
        throw new WorkflowError(`Middleware "${this.name}" has no callbacks or init defined.`);
      }
      this.middlewareCallbacks = await this.initCallbacks();
    }
  }
  /**
   * Gets a callback function by name.
   *
   * @param callback name of the callback to retrieve
   */
  getCallback(callback) {
    return this.middlewareCallbacks?.[callback];
  }
};

// src/middleware/logging.ts
var loggingMiddleware = new WorkflowMiddleware({
  name: "logging",
  callbacks: {
    afterExecution(params) {
      const { context, ...rest } = params;
      console.log("  [Upstash Workflow]: Step executed:", {
        workflowRunId: context.workflowRunId,
        ...rest
      });
    },
    beforeExecution(params) {
      const { context, ...rest } = params;
      console.log("  [Upstash Workflow]: Step execution started:", {
        workflowRunId: context.workflowRunId,
        ...rest
      });
    },
    runStarted(params) {
      const { context, ...rest } = params;
      console.log("  [Upstash Workflow]: Workflow run started:", {
        workflowRunId: context.workflowRunId,
        ...rest
      });
    },
    runCompleted(params) {
      const { context, ...rest } = params;
      console.log("  [Upstash Workflow]: Workflow run completed:", {
        workflowRunId: context.workflowRunId,
        ...rest
      });
    },
    onError: onErrorWithConsole,
    onWarning: onWarningWithConsole,
    onInfo: onInfoWithConsole
  }
});

// src/serve/options.ts
var createResponseData = (workflowRunId, detailedFinishCondition) => {
  const baseHeaders = {
    [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION,
    "Upstash-workflow-sdk": VERSION
  };
  if (detailedFinishCondition?.condition === "auth-fail") {
    return {
      text: JSON.stringify({
        message: AUTH_FAIL_MESSAGE,
        workflowRunId
      }),
      status: 400,
      headers: baseHeaders
    };
  } else if (detailedFinishCondition?.condition === "non-retryable-error") {
    return {
      text: JSON.stringify(formatWorkflowError(detailedFinishCondition.result)),
      status: 489,
      headers: {
        ...baseHeaders,
        "Upstash-NonRetryable-Error": "true"
      }
    };
  } else if (detailedFinishCondition?.condition === "retry-after-error") {
    return {
      text: JSON.stringify(formatWorkflowError(detailedFinishCondition.result)),
      status: 429,
      headers: {
        ...baseHeaders,
        "Retry-After": detailedFinishCondition.result.retryAfter.toString()
      }
    };
  } else if (detailedFinishCondition?.condition === "failure-callback-executed") {
    return {
      text: JSON.stringify({ result: detailedFinishCondition.result ?? void 0 }),
      status: 200,
      headers: baseHeaders
    };
  } else if (detailedFinishCondition?.condition === "failure-callback-undefined") {
    return {
      text: JSON.stringify({
        workflowRunId,
        finishCondition: detailedFinishCondition.condition
      }),
      status: 200,
      headers: {
        ...baseHeaders,
        "Upstash-Workflow-Failure-Callback-Notfound": "true"
      }
    };
  }
  return {
    text: JSON.stringify({
      workflowRunId,
      finishCondition: detailedFinishCondition.condition
    }),
    status: 200,
    headers: baseHeaders
  };
};
var processOptions = (options, internalOptions) => {
  const environment = options?.env ?? (typeof process === "undefined" ? {} : process.env);
  const {
    qstashHandlers,
    defaultClient: qstashClient,
    defaultReceiver: receiver
  } = getQStashHandlerOptions({
    environment,
    qstashClientOption: options?.qstashClient,
    receiverConfig: options && "receiver" in options ? options.receiver ? options.receiver : "set-to-undefined" : "not-set"
  });
  return {
    qstashClient,
    initialPayloadParser: (initialRequest) => {
      if (!initialRequest) {
        return void 0;
      }
      try {
        const parsed = JSON.parse(initialRequest);
        return options?.schema ? options.schema.parse(parsed) : parsed;
      } catch (error) {
        if (error instanceof SyntaxError) {
          return initialRequest;
        }
        throw error;
      }
    },
    receiver,
    baseUrl: environment.UPSTASH_WORKFLOW_URL,
    env: environment,
    disableTelemetry: false,
    ...options,
    // merge middlewares
    middlewares: [options?.middlewares ?? [], options?.verbose ? [loggingMiddleware] : []].flat(),
    internal: {
      generateResponse: internalOptions?.generateResponse ?? ((responseData) => {
        return new Response(responseData.text, {
          status: responseData.status,
          headers: responseData.headers
        });
      }),
      useJSONContent: internalOptions?.useJSONContent ?? false,
      qstashHandlers
    }
  };
};
var determineUrls = async (request, url, baseUrl, dispatchDebug) => {
  const initialWorkflowUrl = url ?? request.url;
  const workflowUrl = baseUrl ? initialWorkflowUrl.replace(/^(https?:\/\/[^/]+)(\/.*)?$/, (_, matchedBaseUrl, path) => {
    return baseUrl + (path || "");
  }) : initialWorkflowUrl;
  if (workflowUrl !== initialWorkflowUrl) {
    await dispatchDebug("onInfo", {
      info: `The workflow URL's base URL has been replaced with the provided baseUrl. Original URL: ${initialWorkflowUrl}, New URL: ${workflowUrl}`
    });
  }
  if (workflowUrl.includes("localhost")) {
    await dispatchDebug("onInfo", {
      info: `Workflow URL contains localhost. This can happen in local development, but shouldn't happen in production unless you have a route which contains localhost. Received: ${workflowUrl}`
    });
  }
  if (!(workflowUrl.startsWith("http://") || workflowUrl.startsWith("https://"))) {
    throw new WorkflowError(
      `Workflow URL should start with 'http://' or 'https://'. Recevied is '${workflowUrl}'`
    );
  }
  return {
    workflowUrl
  };
};
var AUTH_FAIL_MESSAGE = `Failed to authenticate Workflow request. If this is unexpected, see the caveat https://upstash.com/docs/workflow/basics/caveats#avoid-non-deterministic-code-outside-context-run`;

// src/serve/index.ts
var serveBase = (routeFunction, telemetry2, options, internalOptions) => {
  const {
    initialPayloadParser,
    url,
    failureFunction,
    baseUrl,
    env,
    disableTelemetry,
    middlewares,
    internal
  } = processOptions(options, internalOptions);
  telemetry2 = disableTelemetry ? void 0 : telemetry2;
  const { generateResponse: responseGenerator, useJSONContent } = internal;
  const handler = async (request, middlewareManager) => {
    await middlewareManager.dispatchDebug("onInfo", {
      info: `Received request for workflow execution.`
    });
    const { workflowUrl } = await determineUrls(
      request,
      url,
      baseUrl,
      middlewareManager.dispatchDebug.bind(middlewareManager)
    );
    const { isFirstInvocation, workflowRunId, unknownSdk } = validateRequest(request);
    const regionHeader = request.headers.get("upstash-region");
    const { client: regionalClient, receiver: regionalReceiver } = getHandlersForRequest(
      internal.qstashHandlers,
      regionHeader,
      isFirstInvocation
    );
    const requestPayload = await getPayload(request) ?? "";
    await verifyRequest(requestPayload, request.headers.get("upstash-signature"), regionalReceiver);
    middlewareManager.assignWorkflowRunId(workflowRunId);
    await middlewareManager.dispatchDebug("onInfo", {
      info: `Run id identified. isFirstInvocation: ${isFirstInvocation}, unknownSdk: ${unknownSdk}`
    });
    const { rawInitialPayload, steps, isLastDuplicate, workflowRunEnded } = await parseRequest({
      requestPayload,
      isFirstInvocation,
      unknownSdk,
      workflowRunId,
      requester: regionalClient.http,
      messageId: request.headers.get("upstash-message-id"),
      dispatchDebug: middlewareManager.dispatchDebug.bind(middlewareManager)
    });
    if (workflowRunEnded) {
      return responseGenerator(
        createResponseData(workflowRunId, {
          condition: "workflow-already-ended"
        })
      );
    }
    if (isLastDuplicate) {
      return responseGenerator(
        createResponseData(workflowRunId, {
          condition: "duplicate-step"
        })
      );
    }
    const failureCheck = await handleFailure({
      request,
      requestPayload,
      qstashClient: regionalClient,
      initialPayloadParser,
      routeFunction,
      failureFunction,
      env,
      dispatchDebug: middlewareManager.dispatchDebug.bind(middlewareManager)
    });
    if (failureCheck.isErr()) {
      throw failureCheck.error;
    } else if (failureCheck.value.result === "failure-function-executed") {
      await middlewareManager.dispatchDebug("onInfo", {
        info: `Handled failure callback.`
      });
      return responseGenerator(
        createResponseData(workflowRunId, {
          condition: "failure-callback-executed",
          result: failureCheck.value.response
        })
      );
    } else if (failureCheck.value.result === "failure-function-undefined") {
      await middlewareManager.dispatchDebug("onInfo", {
        info: `Failure callback invoked but no failure function defined.`
      });
      return responseGenerator(
        createResponseData(workflowRunId, {
          condition: "failure-callback-undefined"
        })
      );
    }
    const invokeCount = Number(request.headers.get(WORKFLOW_INVOKE_COUNT_HEADER) ?? "0");
    const label = request.headers.get(WORKFLOW_LABEL_HEADER) ?? void 0;
    const workflowRunCreatedAt = request.headers.get(WORKFLOW_CREATED_AT_HEADER);
    const workflowContext = new WorkflowContext({
      qstashClient: regionalClient,
      workflowRunId,
      initialPayload: initialPayloadParser(rawInitialPayload),
      headers: recreateUserHeaders(request.headers),
      steps,
      url: workflowUrl,
      env,
      telemetry: telemetry2,
      invokeCount,
      label,
      workflowRunCreatedAt: Number(workflowRunCreatedAt),
      middlewareManager
    });
    const authCheck = await DisabledWorkflowContext.tryAuthentication(
      routeFunction,
      workflowContext
    );
    if (authCheck.isErr()) {
      throw authCheck.error;
    } else if (authCheck.value === "run-ended") {
      await middlewareManager.dispatchDebug("onError", {
        error: new Error(AUTH_FAIL_MESSAGE)
      });
      return responseGenerator(
        createResponseData(isFirstInvocation ? "no-workflow-id" : workflowContext.workflowRunId, {
          condition: "auth-fail"
        })
      );
    }
    const callReturnCheck = await handleThirdPartyCallResult({
      request,
      requestPayload: rawInitialPayload,
      client: regionalClient,
      workflowUrl,
      telemetry: telemetry2,
      middlewareManager
    });
    if (callReturnCheck.isErr()) {
      throw callReturnCheck.error;
    } else if (callReturnCheck.value === "continue-workflow") {
      const result = isFirstInvocation ? await triggerFirstInvocation({
        workflowContext,
        useJSONContent,
        telemetry: telemetry2,
        invokeCount,
        middlewareManager,
        unknownSdk
      }) : await triggerRouteFunction({
        onStep: async () => {
          if (steps.length === 1) {
            await middlewareManager.dispatchLifecycle("runStarted", {});
          }
          return await routeFunction(workflowContext);
        },
        onCleanup: async (result2) => {
          await middlewareManager.dispatchLifecycle("runCompleted", {
            result: result2
          });
          await triggerWorkflowDelete(
            workflowContext,
            result2,
            false,
            middlewareManager.dispatchDebug.bind(middlewareManager)
          );
        },
        onCancel: async () => {
          await makeCancelRequest(workflowContext.qstashClient.http, workflowRunId);
        },
        middlewareManager
      });
      if (result.isOk() && isInstanceOf(result.value, WorkflowNonRetryableError)) {
        return responseGenerator(
          createResponseData(workflowRunId, {
            condition: "non-retryable-error",
            result: result.value
          })
        );
      }
      if (result.isOk() && isInstanceOf(result.value, WorkflowRetryAfterError)) {
        return responseGenerator(
          createResponseData(workflowRunId, {
            condition: "retry-after-error",
            result: result.value
          })
        );
      }
      if (result.isErr()) {
        throw result.error;
      }
      await middlewareManager.dispatchDebug("onInfo", {
        info: `Workflow endpoint execution completed successfully.`
      });
      return responseGenerator(
        createResponseData(workflowContext.workflowRunId, {
          condition: "success"
        })
      );
    } else if (callReturnCheck.value === "workflow-ended") {
      return responseGenerator(
        createResponseData(workflowContext.workflowRunId, {
          condition: "workflow-already-ended"
        })
      );
    }
    return responseGenerator(
      createResponseData(workflowContext.workflowRunId, {
        condition: "fromCallback"
      })
    );
  };
  const safeHandler = async (request) => {
    const middlewareManager = new MiddlewareManager(middlewares);
    try {
      return await handler(request, middlewareManager);
    } catch (error) {
      const formattedError = formatWorkflowError(error);
      await middlewareManager.dispatchDebug("onError", {
        error: isInstanceOf(error, Error) ? error : new Error(formattedError.message)
      });
      return new Response(JSON.stringify(formattedError), {
        status: 500,
        headers: {
          [WORKFLOW_PROTOCOL_VERSION_HEADER]: WORKFLOW_PROTOCOL_VERSION
        }
      });
    }
  };
  return { handler: safeHandler };
};

// platforms/react-router.ts
var telemetry = {
  sdk: SDK_TELEMETRY,
  framework: "react-router",
  runtime: process.versions.bun ? `bun@${process.versions.bun}/node@${process.version}` : `node@${process.version}`
};
var serve = (routeFunction, options) => {
  const { handler: serveHandler } = serveBase(
    routeFunction,
    telemetry,
    options
  );
  return async ({ request }) => {
    return await serveHandler(request);
  };
};
var createWorkflow = (...params) => {
  const [routeFunction, options = {}] = params;
  return {
    routeFunction,
    options,
    workflowId: void 0
  };
};
var serveMany = (workflows, options) => {
  return serveManyBase({
    workflows,
    getUrl(params) {
      return params.request.url;
    },
    serveMethod: (...params) => serve(...params),
    options
  }).handler;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createWorkflow,
  serve,
  serveMany
});
