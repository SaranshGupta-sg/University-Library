import { QstashError, PublishRequest, HTTPMethods as HTTPMethods$1, FlowControl, Client, Receiver } from '@upstash/qstash';
import { z } from 'zod';

/**
 * Error raised during Workflow execution
 */
declare class WorkflowError extends QstashError {
    constructor(message: string);
}
/**
 * Base error for workflow abort scenarios
 * Raised when a workflow step executes successfully.
 */
declare class WorkflowAbort extends Error {
    stepName: string;
    stepInfo?: Step;
    /**
     * @param stepName name of the aborting step
     * @param stepInfo step information
     */
    constructor(stepName: string, stepInfo?: Step);
}
/**
 * Raised when the workflow is failed due to a non-retryable error
 */
declare class WorkflowNonRetryableError extends WorkflowAbort {
    /**
     * @param message error message to be displayed
     */
    constructor(message?: string);
}
declare class WorkflowRetryAfterError extends WorkflowAbort {
    retryAfter: number | Duration;
    /**
     * @param message error message to be displayed
     * @param retryAfter time in seconds after which the workflow should be retried
     */
    constructor(message: string, retryAfter: number | Duration);
}

type LifeCycleEvent = "beforeExecution" | "afterExecution" | "runStarted" | "runCompleted";
type DebugEvent = "onError" | "onWarning" | "onInfo";
type LifeCycleEventParameters<TResult> = {
    beforeExecution: {
        stepName: string;
    };
    afterExecution: {
        stepName: string;
        result: unknown;
    };
    runStarted: {};
    runCompleted: {
        result: TResult;
    };
};
type DebugEventParameters = {
    onError: {
        error: Error;
    };
    onWarning: {
        warning: string;
    };
    onInfo: {
        info: string;
    };
};
type MiddlewareCallbacks<TInitialPayload, TResult> = Partial<{
    [K in LifeCycleEvent]: (params: LifeCycleEventParameters<TResult>[K] & {
        context: WorkflowContext<TInitialPayload>;
    }) => Promise<void> | void;
} & {
    [K in DebugEvent]: (params: DebugEventParameters[K] & {
        workflowRunId?: string;
    }) => Promise<void> | void;
}>;
type MiddlewareInitCallbacks<TInitialPayload, TResult> = () => Promise<MiddlewareCallbacks<TInitialPayload, TResult>> | MiddlewareCallbacks<TInitialPayload, TResult>;
type MiddlewareCallbackConfig<TInitialPayload, TResult> = {
    init: MiddlewareInitCallbacks<TInitialPayload, TResult>;
} | {
    callbacks: MiddlewareCallbacks<TInitialPayload, TResult>;
};
type MiddlewareParameters<TInitialPayload, TResult> = {
    name: string;
} & MiddlewareCallbackConfig<TInitialPayload, TResult>;
/**
 * Type for the dispatch debug method that can be passed to helper functions
 * without needing to pass generics everywhere
 */
type DispatchDebug = <K extends DebugEvent>(event: K, params: DebugEventParameters[K]) => Promise<void>;
/**
 * Type for the dispatch lifecycle method
 */
type DispatchLifecycle<TResult = unknown> = <K extends LifeCycleEvent>(event: K, params: LifeCycleEventParameters<TResult>[K]) => Promise<void>;

declare class WorkflowMiddleware<TInitialPayload = unknown, TResult = unknown> {
    readonly name: string;
    private initCallbacks?;
    /**
     * Callback functions
     *
     * Initially set to undefined, will be populated after init is called
     */
    private middlewareCallbacks?;
    constructor(parameters: MiddlewareParameters<TInitialPayload, TResult>);
    ensureInit(): Promise<void>;
    /**
     * Gets a callback function by name.
     *
     * @param callback name of the callback to retrieve
     */
    getCallback<K extends keyof MiddlewareCallbacks<TInitialPayload, TResult>>(callback: K): MiddlewareCallbacks<TInitialPayload, TResult>[K] | undefined;
}

/**
 * MiddlewareManager - Simplified middleware dispatcher
 *
 * This class manages middleware execution without requiring generics everywhere.
 * Once created, you can export dispatch methods that handle both lifecycle and debug events.
 */
declare class MiddlewareManager<TInitialPayload = any, TResult = any> {
    private middlewares;
    private workflowRunId;
    private context;
    /**
     * @param middlewares list of workflow middlewares
     */
    constructor(middlewares?: WorkflowMiddleware<TInitialPayload, TResult>[]);
    /**
     * Assign workflow run ID - will be passed to debug events
     *
     * @param workflowRunId workflow run id to assign
     */
    assignWorkflowRunId(workflowRunId: string): void;
    /**
     * Assign context - required for lifecycle events
     *
     * also assigns workflowRunId from context
     *
     * @param context workflow context to assign
     */
    assignContext(context: WorkflowContext<TInitialPayload>): void;
    /**
     * Internal method to execute middlewares with common error handling logic
     *
     * @param event event name to dispatch
     * @param params event parameters
     */
    private executeMiddlewares;
    /**
     * Dispatch a debug event (onError, onWarning, onInfo)
     *
     * @param event debug event name
     * @param params event parameters
     */
    dispatchDebug<K extends DebugEvent>(event: K, params: DebugEventParameters[K]): Promise<void>;
    /**
     * Dispatch a lifecycle event (beforeExecution, afterExecution, runStarted, runCompleted)
     *
     * @param event lifecycle event name
     * @param params event parameters
     */
    dispatchLifecycle<K extends LifeCycleEvent>(event: K, params: LifeCycleEventParameters<TResult>[K]): Promise<void>;
}

type HeadersResponse = {
    headers: Record<string, string>;
    contentType: string;
};

type StepParams = {
    context: WorkflowContext;
} & Pick<HeaderParams, "telemetry"> & Required<Pick<HeaderParams, "step" | "invokeCount">>;
type GetHeaderParams = StepParams;
type GetBodyParams = StepParams & Omit<HeadersResponse, "contentType">;
type SubmitStepParams = StepParams & Pick<HeadersResponse, "headers"> & {
    body: string;
    isParallel: boolean;
};
/**
 * Base class outlining steps. Basically, each step kind (run/sleep/sleepUntil)
 * should have two methods: getPlanStep & getResultStep.
 *
 * getPlanStep works the same way for all so it's implemented here.
 * The different step types will implement their own getResultStep method.
 */
declare abstract class BaseLazyStep<TResult = unknown> {
    readonly stepName: string;
    abstract readonly stepType: StepType;
    protected abstract readonly allowUndefinedOut: boolean;
    protected readonly context: WorkflowContext;
    constructor(context: WorkflowContext, stepName: string);
    /**
     * plan step to submit when step will run parallel with other
     * steps (parallel call state `first`)
     *
     * @param concurrent number of steps running parallel
     * @param targetStep target step id corresponding to this step
     * @returns
     */
    abstract getPlanStep(concurrent: number, targetStep: number): Step<undefined>;
    /**
     * result step to submit after the step executes. Used in single step executions
     * and when a plan step executes in parallel executions (parallel call state `partial`).
     *
     * @param concurrent
     * @param stepId
     */
    abstract getResultStep(concurrent: number, stepId: number): Promise<Step<TResult>>;
    /**
     * parse the out field of a step result.
     *
     * will be called when returning the steps to the context from auto executor
     *
     * @param step step
     * @returns parsed out field
     */
    parseOut(step: Step): TResult;
    protected safeParseOut(out: string, step: Step): TResult;
    protected handleUndefinedOut(step: Step): TResult;
    protected static tryParsing(stepOut: unknown): any;
    getBody({ step }: GetBodyParams): string;
    getHeaders({ context, telemetry, invokeCount, step }: GetHeaderParams): HeadersResponse;
    submitStep({ context, body, headers }: SubmitStepParams): Promise<{
        messageId: string;
    }[]>;
}
type Webhook = {
    webhookUrl: string;
    eventId: string;
};
type WaitForWebhookResponse = {
    timeout: false;
    request: Request;
} | {
    timeout: true;
    request: undefined;
};

declare class AutoExecutor {
    private context;
    private promises;
    private activeLazyStepList?;
    private readonly nonPlanStepCount;
    private readonly steps;
    private indexInCurrentList;
    private readonly invokeCount;
    private readonly telemetry?;
    private readonly dispatchDebug;
    private readonly dispatchLifecycle;
    stepCount: number;
    planStepCount: number;
    protected executingStep: string | false;
    /**
     * @param context workflow context
     * @param steps list of steps
     * @param dispatchDebug debug event dispatcher
     * @param dispatchLifecycle lifecycle event dispatcher
     * @param telemetry optional telemetry information
     * @param invokeCount optional invoke count
     */
    constructor(context: WorkflowContext, steps: Step[], dispatchDebug: DispatchDebug, dispatchLifecycle: DispatchLifecycle, telemetry?: Telemetry, invokeCount?: number);
    /**
     * Adds the step function to the list of step functions to run in
     * parallel. After adding the function, defers the execution, so
     * that if there is another step function to be added, it's also
     * added.
     *
     * After all functions are added, list of functions are executed.
     * If there is a single function, it's executed by itself. If there
     * are multiple, they are run in parallel.
     *
     * If a function is already executing (this.executingStep), this
     * means that there is a nested step which is not allowed. In this
     * case, addStep throws WorkflowError.
     *
     * @param stepInfo step plan to add
     * @returns result of the step function
     */
    addStep<TResult>(stepInfo: BaseLazyStep<TResult>): Promise<TResult>;
    /**
     * Wraps a step function to set this.executingStep to step name
     * before running and set this.executingStep to False after execution
     * ends.
     *
     * this.executingStep allows us to detect nested steps which are not
     * allowed.
     *
     * @param stepName name of the step being wrapped
     * @param stepFunction step function to wrap
     * @returns wrapped step function
     */
    wrapStep<TResult = unknown>(stepName: string, stepFunction: StepFunction<TResult>): TResult | Promise<TResult>;
    /**
     * Executes a step:
     * - If the step result is available in the steps, returns the result
     * - If the result is not available, runs the function
     * - Sends the result to QStash
     *
     * @param lazyStep lazy step to execute
     * @returns step result
     */
    protected runSingle<TResult>(lazyStep: BaseLazyStep<TResult>): Promise<TResult>;
    /**
     * Runs steps in parallel.
     *
     * @param parallelSteps list of lazy steps to run in parallel
     * @returns results of the functions run in parallel
     */
    protected runParallel<TResults extends unknown[]>(parallelSteps: {
        [K in keyof TResults]: BaseLazyStep<TResults[K]>;
    }): Promise<TResults>;
    /**
     * Determines the parallel call state
     *
     * First filters the steps to get the steps which are after `initialStepCount` parameter.
     *
     * Depending on the remaining steps, decides the parallel state:
     * - "first": If there are no steps
     * - "last" If there are equal to or more than `2 * parallelStepCount`. We multiply by two
     *   because each step in a parallel execution will have 2 steps: a plan step and a result
     *   step.
     * - "partial": If the last step is a plan step
     * - "discard": If the last step is not a plan step. This means that the parallel execution
     *   is in progress (there are still steps to run) and one step has finished and submitted
     *   its result to QStash
     *
     * @param parallelStepCount number of steps to run in parallel
     * @param initialStepCount steps after the parallel invocation
     * @returns parallel call state
     */
    protected getParallelCallState(parallelStepCount: number, initialStepCount: number): ParallelCallState;
    /**
     * Get the promise by executing the lazt steps list. If there is a single
     * step, we call `runSingle`. Otherwise `runParallel` is called.
     *
     * @param lazyStepList steps list to execute
     * @returns promise corresponding to the execution
     */
    private getExecutionPromise;
    /**
     * @param lazyStepList steps we executed
     * @param result result of the promise from `getExecutionPromise`
     * @param index index of the current step
     * @returns result[index] if lazyStepList > 1, otherwise result
     */
    private static getResult;
    private deferExecution;
}

type HTTPMethods = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";

type ProviderInfo = {
    /**
     * full url used for request
     */
    url: string;
    /**
     * base url of the request
     */
    baseUrl: string;
    /**
     * route elements which will follow the baseUrl
     */
    route: string[];
    /**
     * headers to include in the request
     */
    appendHeaders: Record<string, string>;
    /**
     * provider owner
     */
    owner: Owner;
    /**
     * method to use in the request
     */
    method: HTTPMethods;
};
type Owner = EmailOwner | LLMOwner;
/**
 * Email
 */
type EmailOwner = "resend";
/**
 * LLM
 */
type LLMOwner = "upstash" | "openai" | "anthropic" | "custom";

/**
 * copies and updates the request by removing the api field and adding url & headers.
 *
 * @param api api field of PublishRequest
 * @returns updated request with provider info
 */
declare const getProviderInfo: (api: Required<PublishRequest>["api"]) => ProviderInfo;

type ApiCallSettings<TBody = unknown, TFields extends object = object> = Omit<CallSettings, "url" | "body"> & {
    body: TBody;
} & TFields;
declare abstract class BaseWorkflowApi {
    protected context: WorkflowContext;
    /**
     * @param context workflow context
     */
    constructor({ context }: {
        context: WorkflowContext;
    });
    /**
     * context.call which uses a QStash API
     *
     * @param stepName name of the step
     * @param settings call settings including api configuration
     * @returns call response
     */
    protected callApi<TResult = unknown, TBody = unknown>(stepName: string, settings: ApiCallSettings<TBody, {
        api: Parameters<typeof getProviderInfo>[0];
    }>): Promise<CallResponse<TResult>>;
}

type CreateChatCompletion$1 = {
    model: string;
    messages: {
        role: "user" | "assistant";
        content: unknown;
    }[];
    max_tokens: number;
    metadata?: object;
    stop_sequences?: string[];
    /**
     * streaming is not possible Upstash Workflow.
     */
    stream?: false;
    system?: string;
    temparature?: number;
    top_k?: number;
    top_p?: number;
};
type ChatCompletion$1 = {
    id: string;
    type: "message";
    role: "assistant";
    content: {
        type: "text";
        text: string;
    }[];
    model: string;
    stop_reasong: string;
    stop_sequence: string[];
    usage: unknown;
};
declare class AnthropicAPI extends BaseWorkflowApi {
    call<TResult = ChatCompletion$1, TBody = CreateChatCompletion$1>(stepName: string, settings: ApiCallSettings<TBody, {
        token: string;
        operation: "messages.create";
    }>): Promise<CallResponse<TResult>>;
}

type Messages = {
    content: string;
    role: "developer" | "system";
    name?: string;
} | {
    content: unknown;
    role: "user";
    name?: string;
} | {
    content: unknown;
    refusal?: string;
    role: "assistant";
    name?: string;
    audio?: unknown;
    tool_calls?: unknown;
} | {
    role: "tool";
    content: string | unknown;
    tool_call_id: string;
} | {
    role: "function";
    content: string | undefined;
    name: string;
};
type CreateChatCompletion = {
    messages: Messages[];
    model: string;
    store?: boolean;
    reasoning_effort?: string;
    metadata?: unknown;
    frequency_penalty?: number;
    logit_bias?: Record<string, number>;
    logprobs?: boolean;
    top_logprobs?: number;
    max_completion_tokens?: number;
    n?: number;
    modalities?: string[];
    prediction?: unknown;
    audio?: unknown;
    presence_penalty?: number;
    response_format?: unknown;
    seed?: number;
    service_tier?: string;
    stop?: string | string[];
    /**
     * streaming is not supported in Upstash Workflow.
     */
    stream?: false;
    temperature?: number;
    top_p?: number;
    tools?: unknown;
    tool_choice?: string;
    parallel_tool_calls?: boolean;
    user?: string;
};
type ChatCompletion = {
    id: string;
    choices: ChatCompletionChoice[];
    created: number;
    model: string;
    object: "chat.completion";
    service_tier?: "scale" | "default" | null;
    system_fingerprint?: string;
    usage?: unknown;
};
type ChatCompletionChoice = {
    finish_reason: "stop" | "length" | "tool_calls" | "content_filter" | "function_call";
    index: number;
    logprobs: unknown;
    message: {
        content: string | null;
        refusal: string | null;
        role: "assistant";
        audio?: unknown;
        tool_calls?: unknown;
    };
};
declare class OpenAIAPI extends BaseWorkflowApi {
    call<TResult = ChatCompletion, TBody = CreateChatCompletion>(stepName: string, settings: ApiCallSettings<TBody, {
        token: string;
        organization?: string;
        baseURL?: string;
        operation: "chat.completions.create";
    }>): Promise<CallResponse<TResult>>;
}

type SendEmail = {
    from: string;
    to: string;
    subject: string;
    bcc?: string | string[];
    cc?: string | string[];
    scheduled_at?: string;
    reply_to?: string | string[];
    html?: string;
    text?: string;
    headers: unknown;
    attachments: unknown;
    tags: {
        name: string;
        value: string;
    }[];
};
type SendEmailResponse = {
    id: string;
};
type SendBatchEmail = SendEmail[];
type SendBatchEmailResponse = {
    data: SendEmailResponse[];
};
declare class ResendAPI extends BaseWorkflowApi {
    call<TBatch extends boolean = false, TResult = TBatch extends true ? SendBatchEmailResponse : SendEmailResponse, TBody = TBatch extends true ? SendBatchEmail : SendEmail>(stepName: string, settings: ApiCallSettings<TBody, {
        token: string;
        batch?: TBatch;
    }>): Promise<CallResponse<TResult>>;
}

declare class WorkflowApi extends BaseWorkflowApi {
    get openai(): OpenAIAPI;
    get resend(): ResendAPI;
    get anthropic(): AnthropicAPI;
}

/**
 * Upstash Workflow context
 *
 * See the docs for fields and methods https://upstash.com/docs/qstash/workflows/basics/context
 */
declare class WorkflowContext<TInitialPayload = unknown> {
    protected readonly executor: AutoExecutor;
    protected readonly steps: Step[];
    /**
     * QStash client of the workflow
     *
     * Can be overwritten by passing `qstashClient` parameter in `serve`:
     *
     * ```ts
     * import { Client } from "@upstash/qstash"
     *
     * export const POST = serve(
     *   async (context) => {
     *     ...
     *   },
     *   {
     *     qstashClient: new Client({...})
     *   }
     * )
     * ```
     */
    readonly qstashClient: WorkflowClient;
    /**
     * Run id of the workflow
     */
    readonly workflowRunId: string;
    /**
     * Creation time of the workflow run
     */
    readonly workflowRunCreatedAt: number;
    /**
     * URL of the workflow
     *
     * Can be overwritten by passing a `url` parameter in `serve`:
     *
     * ```ts
     * export const POST = serve(
     *   async (context) => {
     *     ...
     *   },
     *   {
     *     url: "new-url-value"
     *   }
     * )
     * ```
     */
    readonly url: string;
    /**
     * Payload of the request which started the workflow.
     *
     * To specify its type, you can define `serve` as follows:
     *
     * ```ts
     * // set requestPayload type to MyPayload:
     * export const POST = serve<MyPayload>(
     *   async (context) => {
     *     ...
     *   }
     * )
     * ```
     *
     * By default, `serve` tries to apply `JSON.parse` to the request payload.
     * If your payload is encoded in a format other than JSON, you can utilize
     * the `initialPayloadParser` parameter:
     *
     * ```ts
     * export const POST = serve<MyPayload>(
     *   async (context) => {
     *     ...
     *   },
     *   {
     *     initialPayloadParser: (initialPayload) => {return doSomething(initialPayload)}
     *   }
     * )
     * ```
     */
    readonly requestPayload: TInitialPayload;
    /**
     * headers of the initial request
     */
    readonly headers: Headers;
    /**
     * Map of environment variables and their values.
     *
     * Can be set using the `env` option of serve:
     *
     * ```ts
     * export const POST = serve<MyPayload>(
     *   async (context) => {
     *     const key = context.env["API_KEY"];
     *   },
     *   {
     *     env: {
     *       "API_KEY": "*****";
     *     }
     *   }
     * )
     * ```
     *
     * Default value is set to `process.env`.
     */
    readonly env: Record<string, string | undefined>;
    /**
     * Label to apply to the workflow run.
     *
     * Can be used to filter the workflow run logs.
     *
     * Can be set by passing a `label` parameter when triggering the workflow
     * with `client.trigger`:
     *
     * ```ts
     * await client.trigger({
     *   url: "https://workflow-endpoint.com",
     *   label: "my-label"
     * });
     * ```
     */
    readonly label?: string;
    constructor({ qstashClient, workflowRunId, workflowRunCreatedAt, headers, steps, url, initialPayload, env, telemetry, invokeCount, label, middlewareManager, }: {
        qstashClient: WorkflowClient;
        workflowRunId: string;
        workflowRunCreatedAt: number;
        headers: Headers;
        steps: Step[];
        url: string;
        initialPayload: TInitialPayload;
        env?: Record<string, string | undefined>;
        telemetry?: Telemetry;
        invokeCount?: number;
        label?: string;
        middlewareManager?: MiddlewareManager<TInitialPayload>;
    });
    /**
     * Executes a workflow step
     *
     * ```typescript
     * const result = await context.run("step 1", () => {
     *   return "result"
     * })
     * ```
     *
     * Can also be called in parallel and the steps will be executed
     * simulatenously:
     *
     * ```typescript
     * const [result1, result2] = await Promise.all([
     *   context.run("step 1", () => {
     *     return "result1"
     *   }),
     *   context.run("step 2", async () => {
     *     return await fetchResults()
     *   })
     * ])
     * ```
     *
     * @param stepName name of the step
     * @param stepFunction step function to be executed
     * @returns result of the step function
     */
    run<TResult>(stepName: string, stepFunction: StepFunction<TResult>): Promise<TResult>;
    /**
     * Stops the execution for the duration provided.
     *
     * ```typescript
     * await context.sleep('sleep1', 3) // wait for three seconds
     * ```
     *
     * @param stepName
     * @param duration sleep duration in seconds
     * @returns undefined
     */
    sleep(stepName: string, duration: number | Duration): Promise<void>;
    /**
     * Stops the execution until the date time provided.
     *
     * ```typescript
     * await context.sleepUntil('sleep1', Date.now() / 1000 + 3) // wait for three seconds
     * ```
     *
     * @param stepName
     * @param datetime time to sleep until. Can be provided as a number (in unix seconds),
     *   as a Date object or a string (passed to `new Date(datetimeString)`)
     * @returns undefined
     */
    sleepUntil(stepName: string, datetime: Date | string | number): Promise<void>;
    /**
     * Makes a third party call through QStash in order to make a
     * network call without consuming any runtime.
     *
     * ```ts
     * const { status, body } = await context.call<string>(
     *   "post call step",
     *   {
     *     url: "https://www.some-endpoint.com/api",
     *     method: "POST",
     *     body: "my-payload"
     *   }
     * );
     * ```
     *
     * tries to parse the result of the request as JSON. If it's
     * not a JSON which can be parsed, simply returns the response
     * body as it is.
     *
     * @param stepName
     * @param url url to call
     * @param method call method. "GET" by default.
     * @param body call body
     * @param headers call headers
     * @param retries number of call retries. 0 by default
     * @param retryDelay delay / time gap between retries.
     * @param timeout max duration to wait for the endpoint to respond. in seconds.
     * @returns call result as {
     *     status: number;
     *     body: unknown;
     *     header: Record<string, string[]>
     *   }
     */
    call<TResult = unknown>(stepName: string, settings: CallSettings): Promise<CallResponse<TResult>>;
    call<TResult extends {
        workflowRunId: string;
    } = {
        workflowRunId: string;
    }, TBody = unknown>(stepName: string, settings: LazyInvokeStepParams<TBody, unknown> & Pick<CallSettings, "timeout">): Promise<CallResponse<TResult>>;
    /**
     * Pauses workflow execution until a specific event occurs or a timeout is reached.
     *
     *```ts
     * const result = await workflow.waitForEvent("payment-confirmed", "payment.confirmed", {
     *   timeout: "5m"
     * });
     *```
     *
     * To notify a waiting workflow:
     *
     * ```ts
     * import { Client } from "@upstash/workflow";
     *
     * const client = new Client({ token: "<QSTASH_TOKEN>" });
     *
     * await client.notify({
     *   eventId: "payment.confirmed",
     *   data: {
     *     amount: 99.99,
     *     currency: "USD"
     *   }
     * })
     * ```
     *
     * Alternatively, you can use the `context.notify` method.
     *
     * @param stepName
     * @param eventId - Unique identifier for the event to wait for
     * @param options - Configuration options.
     * @returns `{ timeout: boolean, eventData: TEventData }`.
     *   The `timeout` property specifies if the workflow has timed out. The `eventData`
     *   is the data passed when notifying this workflow of an event.
     */
    waitForEvent<TEventData = unknown>(stepName: string, eventId: string, options?: WaitEventOptions): Promise<WaitStepResponse<TEventData>>;
    /**
     * Notify workflow runs waiting for an event
     *
     * ```ts
     * const { eventId, eventData, notifyResponse } = await context.notify(
     *   "notify step", "event-id", "event-data"
     * );
     * ```
     *
     * Upon `context.notify`, the workflow runs waiting for the given eventId (context.waitForEvent)
     * will receive the given event data and resume execution.
     *
     * The response includes the same eventId and eventData. Additionally, there is
     * a notifyResponse field which contains a list of `Waiter` objects, each corresponding
     * to a notified workflow run.
     *
     * @param stepName
     * @param eventId event id to notify
     * @param eventData event data to notify with
     * @returns notify response which has event id, event data and list of waiters which were notified
     */
    notify(stepName: string, eventId: string, eventData: unknown): Promise<NotifyStepResponse>;
    invoke<TInitialPayload, TResult>(stepName: string, settings: LazyInvokeStepParams<TInitialPayload, TResult>): Promise<InvokeStepResponse<TResult>>;
    createWebhook(stepName: string): Promise<Webhook>;
    waitForWebhook(stepName: string, webhook: Webhook, timeout: Duration): Promise<WaitForWebhookResponse>;
    /**
     * Cancel the current workflow run
     *
     * Will throw WorkflowCancelAbort to stop workflow execution.
     * Shouldn't be inside try/catch.
     */
    cancel(): Promise<void>;
    /**
     * Adds steps to the executor. Needed so that it can be overwritten in
     * DisabledWorkflowContext.
     */
    protected addStep<TResult = unknown>(step: BaseLazyStep<TResult>): Promise<TResult>;
    get api(): WorkflowApi;
}

/**
 * Interface for Client with required methods
 *
 * Neeeded to resolve import issues
 */
type WorkflowClient = {
    batch: InstanceType<typeof Client>["batch"];
    batchJSON: InstanceType<typeof Client>["batchJSON"];
    publishJSON: InstanceType<typeof Client>["publishJSON"];
    publish: InstanceType<typeof Client>["publish"];
    http: InstanceType<typeof Client>["http"];
};
/**
 * Interface for Receiver with required methods
 *
 * Neeeded to resolve import issues
 */
type WorkflowReceiver = {
    verify: InstanceType<typeof Receiver>["verify"];
};
declare const StepTypes: readonly ["Initial", "Run", "SleepFor", "SleepUntil", "Call", "Wait", "Notify", "Invoke", "CreateWebhook", "WaitForWebhook"];
type StepType = (typeof StepTypes)[number];
type ThirdPartyCallFields<TBody = unknown> = {
    /**
     * Third party call URL. Set when context.call is used.
     */
    callUrl: string;
    /**
     * Third party call method. Set when context.call is used.
     */
    callMethod: HTTPMethods$1;
    /**
     * Third party call body. Set when context.call is used.
     */
    callBody: TBody;
    /**
     * Third party call headers. Set when context.call is used.
     */
    callHeaders: Record<string, string>;
};
type WaitFields = {
    waitEventId: string;
    timeout: string;
    waitTimeout?: boolean;
};
type NotifyFields = {
    notifyEventId?: string;
    eventData?: string;
};
type Step<TResult = unknown, TBody = unknown> = {
    /**
     * index of the step
     */
    stepId: number;
    /**
     * name of the step
     */
    stepName: string;
    /**
     * type of the step (Initial/Run/SleepFor/SleepUntil/Call)
     */
    stepType: StepType;
    /**
     * step result. Set if context.run or context.call are used.
     */
    out?: TResult;
    /**
     * sleep duration in seconds. Set when context.sleep is used.
     */
    sleepFor?: number | Duration;
    /**
     * unix timestamp (in seconds) to wait until. Set when context.sleepUntil is used.
     */
    sleepUntil?: number;
    /**
     * number of steps running concurrently if the step is in a parallel run.
     * Set to 1 if step is not parallel.
     */
    concurrent: number;
    /**
     * target step of a plan step. In other words, the step to assign the
     * result of a plan step.
     *
     * undefined if the step is not a plan step (of a parallel run). Otherwise,
     * set to the target step.
     */
    targetStep?: number;
} & (ThirdPartyCallFields<TBody> | {
    [P in keyof ThirdPartyCallFields]?: never;
}) & (WaitFields | {
    [P in keyof WaitFields]?: never;
}) & (NotifyFields | {
    [P in keyof NotifyFields]?: never;
});
type RawStep = {
    messageId: string;
    body: string;
    callType: "step" | "toCallback" | "fromCallback";
};
type SyncStepFunction<TResult> = () => TResult;
type AsyncStepFunction<TResult> = () => Promise<TResult>;
type StepFunction<TResult> = AsyncStepFunction<TResult> | SyncStepFunction<TResult>;
type ParallelCallState = "first" | "partial" | "discard" | "last";
type RouteFunction<TInitialPayload, TResult = unknown> = (context: WorkflowContext<TInitialPayload>) => Promise<TResult>;
type FinishCondition = "success" | "duplicate-step" | "fromCallback" | "auth-fail" | "failure-callback-executed" | "failure-callback-undefined" | "workflow-already-ended" | WorkflowNonRetryableError;
type DetailedFinishCondition = {
    condition: Exclude<FinishCondition, WorkflowNonRetryableError | "failure-callback-executed">;
    result?: never;
} | {
    condition: "non-retryable-error";
    result: WorkflowNonRetryableError;
} | {
    condition: "retry-after-error";
    result: WorkflowRetryAfterError;
} | {
    condition: "failure-callback-executed";
    result: string | void;
};
type WorkflowContextWithoutMethods<TInitialPayload> = Omit<WorkflowContext<TInitialPayload>, "run" | "sleepUntil" | "sleep" | "call" | "waitForEvent" | "notify" | "cancel" | "api" | "invoke" | "createWebhook" | "waitForWebhook">;
type QStashClientExtraConfig = Omit<NonNullable<ConstructorParameters<typeof Client>[0]>, "baseUrl" | "token">;
type WorkflowServeOptions<TInitialPayload = unknown, TResult = unknown> = {
    /**
     * QStash client or client configuration
     *
     * Can be either:
     * - A WorkflowClient instance
     * - Client configuration options (omitting baseUrl and token, which will be read from env vars)
     */
    qstashClient?: WorkflowClient | QStashClientExtraConfig;
    /**
     * Url of the endpoint where the workflow is set up.
     *
     * If not set, url will be inferred from the request.
     */
    url?: string;
    /**
     * Receiver to verify *all* requests by checking if they come from QStash
     *
     * By default, a receiver is created from the env variables
     * QSTASH_CURRENT_SIGNING_KEY and QSTASH_NEXT_SIGNING_KEY if they are set.
     */
    receiver?: WorkflowReceiver;
    /**
     * Failure function called when QStash retries are exhausted while executing
     * the workflow.
     *
     * @param context workflow context at the moment of error
     * @param failStatus error status
     * @param failResponse error message
     * @returns void
     */
    failureFunction?: (failureData: {
        context: WorkflowContextWithoutMethods<TInitialPayload>;
        failStatus: number;
        failResponse: string;
        failHeaders: Record<string, string[]>;
        failStack: string;
    }) => Promise<void | string> | void | string;
    /**
     * Base Url of the workflow endpoint
     *
     * Can be used to set if there is a local tunnel or a proxy between
     * QStash and the workflow endpoint.
     *
     * Will be set to the env variable UPSTASH_WORKFLOW_URL if not passed.
     * If the env variable is not set, the url will be infered as usual from
     * the `request.url` or the `url` parameter in `serve` options.
     *
     * @default undefined
     */
    baseUrl?: string;
    /**
     * Optionally, one can pass an env object mapping environment
     * variables to their keys.
     *
     * Useful in cases like cloudflare with hono.
     */
    env?: Record<string, string | undefined>;
    /**
     * By default, Workflow SDK sends telemetry about SDK version, framework or runtime.
     *
     * Set `disableTelemetry` to disable this behavior.
     *
     * @default false
     */
    disableTelemetry?: boolean;
    /**
     * List of workflow middlewares to use
     */
    middlewares?: WorkflowMiddleware<TInitialPayload, TResult>[];
    /**
     * Whether to enable verbose logging for debugging purposes
     */
    verbose?: boolean;
} & ExclusiveValidationOptions<TInitialPayload>;
type ValidationOptions<TInitialPayload> = {
    schema?: z.ZodType<TInitialPayload>;
    initialPayloadParser?: (initialPayload: string) => TInitialPayload;
};
type ExclusiveValidationOptions<TInitialPayload> = {
    schema?: ValidationOptions<TInitialPayload>["schema"];
    initialPayloadParser?: never;
} | {
    schema?: never;
    initialPayloadParser?: ValidationOptions<TInitialPayload>["initialPayloadParser"];
};
type Telemetry = {
    /**
     * sdk version
     */
    sdk: string;
    /**
     * platform (such as nextjs/cloudflare)
     */
    framework?: string;
    /**
     * node version
     */
    runtime?: string;
};
/**
 * Payload passed as body in failureFunction
 */
type FailureFunctionPayload = {
    /**
     * error name
     */
    error: string;
    /**
     * error message
     */
    message: string;
    /**
     * error stack trace if available
     */
    stack?: string;
};
/**
 * Makes all fields except the ones selected required
 */
type RequiredExceptFields<T, K extends keyof T> = Omit<Required<T>, K> & Partial<Pick<T, K>>;
type Waiter = {
    url: string;
    deadline: number;
    headers: Record<string, string[]>;
    timeoutUrl?: string;
    timeoutBody?: unknown;
    timeoutHeaders?: Record<string, string[]>;
};
type NotifyResponse = {
    waiter: Waiter;
    messageId: string;
    error: string;
};
type WaitRequest = {
    url: string;
    step: Step;
    timeout: string;
    timeoutUrl?: string;
    timeoutBody?: string;
    timeoutHeaders?: Record<string, string[]>;
};
type WaitStepResponse<TEventData = unknown> = {
    /**
     * whether the wait for event step timed out. false if
     * the step is notified
     */
    timeout: boolean;
    /**
     * body passed in notify request
     */
    eventData: TEventData;
};
type NotifyStepResponse = {
    /**
     * notified event id
     */
    eventId: string;
    /**
     * event data sent with notify
     */
    eventData: unknown;
    /**
     * response from notify
     */
    notifyResponse: NotifyResponse[];
};
type CallResponse<TResult = unknown> = {
    status: number;
    body: TResult;
    header: Record<string, string[]>;
};
/**
 * Valid duration string formats
 * @example "30s" // 30 seconds
 * @example "5m"  // 5 minutes
 * @example "2h"  // 2 hours
 * @example "1d"  // 1 day
 */
type Duration = `${bigint}${"s" | "m" | "h" | "d"}`;
interface WaitEventOptions {
    /**
     * Duration in seconds to wait for an event before timing out the workflow.
     * @example 300 // 5 minutes in seconds
     * @example "5m" // 5 minutes as duration string
     * @default "7d"
     */
    timeout?: number | Duration;
}
type CallSettings = {
    url: string;
    method?: HTTPMethods$1;
    body?: string;
    headers?: Record<string, string>;
    retries?: number;
    retryDelay?: string;
    timeout?: Duration | number;
    flowControl?: FlowControl;
};
type HeaderParams = {
    /**
     * whether the request is a first invocation request.
     */
    initHeaderValue: "true" | "false";
    /**
     * run id of the workflow
     */
    workflowRunId: string;
    /**
     * url where the workflow is hosted
     */
    workflowUrl: string;
    /**
     * user headers which will be forwarded in the request
     */
    userHeaders?: Headers;
    /**
     * telemetry to include in timeoutHeaders.
     *
     * Only needed/used when the step is a waitForEvent step
     */
    telemetry?: Telemetry;
    /**
     * invoke count to include in headers
     */
    invokeCount?: number;
} & ({
    /**
     * step to generate headers for
     */
    step: Step;
    /**
     * number of retries in context.call
     */
    callRetries?: number;
    /**
     * retry delay to include in headers.
     */
    callRetryDelay?: string;
    /**
     * timeout duration in context.call
     */
    callTimeout?: number | Duration;
    /**
     * Settings for controlling the number of active requests
     * and number of requests per second with the same key.
     *
     * will be passed in context.call.
     */
    callFlowControl?: FlowControl;
} | {
    /**
     * step not passed. Either first invocation or simply getting headers for
     * third party callack.
     */
    step?: never;
    /**
     * number of retries in context.call
     *
     * set to never because this is not a context.call step
     */
    callRetries?: never;
    /**
     * retry delay to include in headers.
     *
     * set to never because this is not a context.call step
     */
    callRetryDelay?: never;
    /**
     * timeout duration in context.call
     *
     * set to never because this is not a context.call step
     */
    callTimeout?: never;
    /**
     * Settings for controlling the number of active requests
     * and number of requests per second with the same key.
     *
     * will be passed in context.call.
     */
    callFlowControl?: never;
});
type InvokeWorkflowRequest = {
    workflowUrl: string;
    workflowRunId: string;
    workflowRunCreatedAt: number;
    headers: Record<string, string[]>;
    step: Step;
    body?: string;
};
type LazyInvokeStepParams<TInitiaPayload, TResult> = {
    workflow: InvokableWorkflow<TInitiaPayload, TResult>;
    workflowRunId?: string;
    label?: string;
} & Pick<CallSettings, "retries" | "headers" | "flowControl" | "retryDelay"> & (TInitiaPayload extends undefined ? {
    body?: undefined;
} : {
    body: TInitiaPayload;
});
type InvokeStepResponse<TBody> = {
    body: TBody;
    isCanceled?: boolean;
    isFailed?: boolean;
};
type InvokableWorkflow<TInitialPayload, TResult> = {
    routeFunction: RouteFunction<TInitialPayload, TResult>;
    options: WorkflowServeOptions<TInitialPayload, TResult>;
    workflowId?: string;
    /**
     * whether the invoked workflow should use JSON content type for initial trigger
     *
     * this is set by platform createWorkflow helpers and is not part of public serve options
     */
    useJSONContent?: boolean;
};

export { type AsyncStepFunction as A, type CallResponse as C, type DetailedFinishCondition as D, type ExclusiveValidationOptions as E, type FailureFunctionPayload as F, type HeaderParams as H, type InvokableWorkflow as I, type LazyInvokeStepParams as L, type NotifyResponse as N, type ParallelCallState as P, type QStashClientExtraConfig as Q, type RawStep as R, type StepType as S, type Telemetry as T, WorkflowMiddleware as W, type WorkflowClient as a, type WorkflowReceiver as b, type RouteFunction as c, type WorkflowServeOptions as d, type Waiter as e, type CallSettings as f, type Duration as g, type FinishCondition as h, type InvokeStepResponse as i, type InvokeWorkflowRequest as j, type NotifyStepResponse as k, type RequiredExceptFields as l, type Step as m, type StepFunction as n, StepTypes as o, type SyncStepFunction as p, type WaitEventOptions as q, type WaitRequest as r, type WaitStepResponse as s, WorkflowAbort as t, WorkflowContext as u, WorkflowError as v, WorkflowNonRetryableError as w, WorkflowRetryAfterError as x };
